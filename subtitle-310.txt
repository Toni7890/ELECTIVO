Hola y bienvenidos a otro tutorial sobre el código de Python para todos. En este tutorial, vamos a jugar con la geocodificación, que consiste en tomar una versión de texto de una dirección y convertirla en una dirección conocida para una ubicación. Esto lo vemos todo el tiempo en las aplicaciones de mapas. Esta aplicación de mapas que estoy usando se llama OpenStreetMap. Es un código abierto, mantenido abiertamente. Es una organización maravillosa que nos ofrece una alternativa a las empresas de mapas comerciales, como Google Map, que juegan con todos nosotros. Soy un gran fanático del código abierto, un gran fanático de los recursos de datos. Voy a buscar un lugar, uno de mis restaurantes favoritos en todo el mundo. Estoy usando una dirección de texto y digo: ¿dónde está esta cosa? Me encontró y encontró todo este anuncio, y aquí vemos cosas como las coordenadas del GPS, las coordenadas de latitud y longitud. Hay uno de mis restaurantes favoritos en el mundo. El acto de pasar de una dirección de texto a una ubicación se denomina geocodificación. Es algo muy común. Tenemos un poco de código de muestra aquí. Voy a editar este código. Puedes obtenerlo en www.py4e.com/code3/opengeo.py y guardarlo en algunas ubicaciones para poder editar y jugar con este fragmento de código. Lo tengo aquí mismo. De hecho, estoy editando la copia maestra. Está en GitHub, así que voy a poder arreglarlo. No te preocupes por eso. Vamos a hacer un pequeño recorrido. La API que vamos a crear es una cosa llamada Geo API y es una empresa que toma los datos de OpenStreetMap y los pone a nuestra disposición en esta API de geocodificación, por ejemplo. Esto es lo que vamos a hacer. Puede ver que la idea de la geocodificación consiste en tomar un texto, como he dicho, una dirección de texto, hay todo tipo de cosas. Puedes jugar con él. Puedes jugar, te dan parques infantiles gratis. Si nos fijamos en esto, no es exactamente gratis. Hay un nivel gratuito. Aún tienes que conseguir una clave de API. Si empiezas a usarlo cada vez más, tienes que pagar dinero y se vuelve bastante alto. Son 250.000 como sea, 600 dólares al mes. Ahí es donde está la verdadera API. Pero si echas un vistazo al código, no vamos a acceder a esa API porque, de lo contrario, tendrías que registrarte para crear una cuenta. Aunque sería un buen ejercicio, definitivamente podrías usar su punto final de API oficial si te registraste para obtener una cuenta. Pero le he dado lo que yo llamo un indicador de eso con una tasa muy limitada. Significa que tengo una copia. Tengo una base de datos en la que guardo en caché las cosas que se usan con más frecuencia y uso Cloudflare, y hablamos de eso en la conferencia. También tiene una velocidad muy limitada, lo que significa que te ralentiza a pasos agigantados si lo usas en exceso. El límite de tarifa está diseñado para permitirle hacer lo que necesita para esta clase, pero no más. El prefijo para esto es py4e-data.dr-chuck.net/opengeo?. Luego, coloca un parámetro de consulta q igual a. Tengo esto y ves que la q es igual a, es solo URL y HTTP, el signo más, y ese es el espacio, esto se llama codificación de URL y el porcentaje dos C está codificado en URL. Porque no puedes simplemente poner una coma ahí, sino que tienes que cogerla y codificarla. Pero si hacemos clic en este clic, obtendrás algo de JSON. Justo como hablamos en la conferencia y hay todo tipo de cosas. Es una colección de características, lo que significa que es una matriz con el nombre de las características. Entonces tienes el país. Tienes la latitud y la longitud, que vamos a buscar. A continuación, vamos a ver esta dirección formateada. Puede probar esto en el navegador sin necesidad de una clave. Vamos a recuperar esto. Ahora, hay un poco de cosas que tenemos que hacer. No te preocupes demasiado por esto y dado que esta URL abierta quiere comprobar a veces los certificados del HTTPS, queremos decirle que vamos a tomar datos a pesar de que Python puede que el certificado no sea muy conocido. Esto se debe a que Python, la última vez que lo comprobé , no incluye un montón de certificados conocidos. Es una larga historia. Aquí tienes un código. Básicamente, esto quiere decir que no vamos a verificar el certificado. Ahora, si miramos el certificado de esto, podemos ver que se trata de un contenido seguro verificado y que se trata de un certificado de Cloudflare, y aquí tienes más información al respecto, bla, bla, bla. Lo que estamos diciendo es que le estamos diciendo a Python que no mire demasiado de cerca estas cosas porque solo las estamos leyendo. Probablemente querrías resolver este problema si estuvieras trabajando en la producción, pero para nosotros, esta es la forma más rápida de hacerlo. Hago un gran bucle y pido una ubicación. Si presiono Entrar, se romperá, lo elimino y luego creo un diccionario para hacer esta pequeña cosa de q igual a igual. Ahora, podría cambiar el espacio a un signo más, podría cambiar la coma a %2c o podría llamar a una biblioteca llamada urllib.parse.url.urlencode (parms), que toma un par clave-valor en un diccionario, por lo que q es igual a una dirección, y eso hace todas las cosas sofisticadas. Así que lo imprimo y, a continuación, uso urllib.request open con esa URL, el contexto es igual a ctx, ignoro cualquier problema con el certificado y, a continuación, leo los datos de la URL. Ahora, si analizamos los datos sin procesar, permítanme recuperarlos de nuevo. Si nos fijamos en los datos sin procesar, esto es lo que realmente parece. Es muy compacto y denso, no tiene muchos espacios. La bonita impresión, como bien sabemos, dice: Oh, dejemos algunos espacios para que al menos podamos averiguar qué está pasando. luego está este visor JSON que no es realmente lo que va a volver, pero puedes mostrar y ocultar cosas en este visor JSON. Está bien, supongo, pero me gusta ver los datos sin procesar. Me gusta que esté bien impreso. En este navegador en particular, que estoy usando, es Firefox, cuando ve JSON, te da algunas opciones sobre lo que se supone que funciona. Ahora, esta decodificación, ya hemos hablado de esto antes. Los datos de la web que acabamos de obtener están en UTF-8, y eso se debe a que puede haber todo tipo de caracteres aquí que no sean simples caracteres ASCII, por lo que la web prácticamente usa UTF-8. Cuando obtenemos una lectura, que es UTF-8, hemos leído datos de Internet y son datos UTF-8. Decode dice: vale, míralo, asegúrate de que es UTF-8 y luego devuélvemelo en forma de datos de cadena de Python, que es Unicode, por lo que Unicode no es lo mismo que UTF-8, Unicode es la forma en que manipulamos las cosas dentro de Python. Al hacer que todo sea Python, todo Unicode y Python, todo funcione dentro de Python, puedes codificarlo y decodificarlo cuando lo mueves hacia afuera y hacia adentro. Luego decimos cuántos caracteres tenemos y luego los analizamos. json.loads es un análisis y puede fallar. Luego buscamos un control de cordura para asegurarnos de que lo de las características está ahí, así que eso es buscar esto, como comprobar si existe. Si nos fijamos en las características, las características son una matriz y, por motivos de cordura, también decimos: oye, solo tenemos una de vuelta. Ahora, en este ejemplo de Ann Arbor, va a funcionar. Pero si pones algo, este chequeo de cordura puede funcionar o no. Lo que voy a hacer es, bueno, vamos a ejecutarlo. Lo ejecutaré sin dejar de comentar nada. Así que volvamos aquí y voy a decir Python opengeo.py, y voy a escribir Ann Arbor, Michigan. Así que lo está recuperando. Oh, lo escribí mal. Así que ves la limitación de velocidad en acción. Así que se dio cuenta de que había cometido un error tipográfico y fue y encontró Ann Arbor, Michigan, encontró el lugar real, y eso es parte de lo que haces. Esta geocodificación es una especie de motor de búsqueda. Cometí un error. Ahora, te darás cuenta de que es mucho más rápido si lo escribo bien porque ya lo tiene y, por lo tanto, limita la velocidad de las cosas. Mira lo rápido que fue. Así funcionan los proxies. En la primera, cuando lo escribí mal, el proxy te estaba ralentizando activamente. Estoy como, oh, mi código no funciona. Pero me estaba frenando activamente porque estaba enfadado conmigo porque estaba pidiendo demasiadas cosas. Pero entonces no te limita la tarifa de las cosas que ya tiene, que son baratas porque todo es muy bueno como proxy. Pero recuperamos los datos, tenemos 13 o 19 caracteres. Hemos descubierto cómo analizar la latitud y la longitud. Mira, lo imprimimos y luego tenemos la ubicación. Ahora, no se me ocurre una mejor manera de describirlo. Vamos a borrar un montón de código funcional. Voy a borrar esto, voy a borrar esto. Voy a decir lat = 42, lon = 42 y ubicación = Jerk Pit. Ahora, lo que hice fue que todo ese código que se veía genial ya no existe. Si lo vuelvo a ejecutar, puedo decir Ann Arbor, Michigan. Mira, tienes un error de descarga. Era como: No sé qué es eso. Era infeliz. Pero te darás cuenta de que este código de error de descarga está marcado porque estaba escribiendo cursores y teclas y cosas raras y no estaba contento. Hagámoslo otra vez. Me pregunto qué provocaría eso en esto. Verán que estamos corriendo, pero no estamos viendo la latitud ni la longitud. Déjame mostrarte cómo construyo este código. Lo primero que voy a hacer es imprimir este material para que lo veamos. Ahora, estos son los mismos datos que vimos en el navegador. Lo que quiero de estos datos, y me lleva un tiempo averiguarlo, es que quiero este último y este valor de largo. Puedo adivinar qué es esto, pero te mostraré cómo lo resuelvo. Miro esto y digo: lo externo que quiero son características. Este es un diccionario externo, básicamente características. Eso está en esta variable, js. Es una variable de diccionario. Si digo imprimir son subfunciones. Lo que voy a hacer es comentar esta parte y vamos a hacer una sangría en ella. Tengo que poner un corsé rizado cerrado allí, con una coma = 4. Lo que voy a hacer es hacer ejercicio en casa. Originalmente, estaba descartando js, ahora voy a volcar js por características. Voy a guardar eso. Tengo que seguir ejecutándolo porque no lo escribí correctamente. Tengo un paréntesis extra y pongo punto y coma porque he escrito demasiado Java y JavaScript en mi vida y no puedo evitarlo. Tengo que añadir el json.dumps. Aquí vamos. Debería haber copiado eso de la línea anterior. Ahora, tengo que profundizar en un nivel y luego tengo una bonita impresión. Eso es json.dumps con una sangría de cuatro. Ahora, ¿qué ves? Parece sutil, pero entré y ahora lo único que veo es la matriz. En esta matriz, está el cero con objeto o el cero con diccionario en esta matriz. Ahora, lo que voy a hacer es hacer un pequeño cambio aquí porque lo que salió de las subfunciones de js es una matriz y voy a tomar el primer elemento de esa matriz. Lo que notarán la próxima vez es que esta será la parte exterior porque entramos en esta matriz por debajo de cero. Verá, lo exterior ahora es un diccionario y es de tipo Feature. Una de las claves es tipo y otra es propiedades. Ahora, queremos que las cosas estén dentro de las propiedades. Lo que estamos imprimiendo aquí lo queremos incluir en la clave de ese diccionario. Tenemos un diccionario, pero tenemos una matriz inferior a cero, que devuelve un diccionario, y ahora vamos a obtener las subpropiedades. Esto parece lento, pero va a terminar. Ahora lo que tenemos es un diccionario. La cadena larga ahora es un diccionario. Déjame mover esto. Esa cadena larga es un diccionario y dentro de ese diccionario hay un lon y un lat. Ahora, solo para hacer pruebas, voy a decir que busques en ese diccionario, mucho. Voy a volver a ejecutarlo ahora. Vemos que lo que realmente se recuperó usando todo esto fue el número, es decir, la longitud. Ahora lo que voy a hacer es que he llegado hasta aquí. Ahora lo que voy a hacer es que, en lugar de que la longitud sea 42, eso es lo que el león buscará hacia arriba. Prácticamente podemos decir que el último va a ser el último. Creo que ahora vamos a poder mirar hacia arriba a lo largo y ancho. El último y el largo son correctos. Ahora, lo olvidé. Voy a quitar esto de la sentencia print, de la impresión de depuración y volveré a ejecutarlo. Hemos encontrado el último y el préstamo. He subido ahora, así que no voy a imprimir mucho. Eso es fácil. Solo está formateado. La clave dentro de las propiedades está formateada. Ahora lo que puedo hacer es encontrar la ubicación cogiendo esto y simplemente buscando formateado. Solo comentaré esto un poco temporalmente. Acabo de llegar a Control C, Ann Arbor, Michigan. Ahora obtengo la dirección formateada. Obtengo la latitud y obtengo la longitud. Cuando empezamos, tenía un código que se parecía mucho a esto. Era un orden un poco diferente. Me viste ahondar sucesivamente en esto jerárquicamente. Ahora estaba como, aquí vamos. Es un diccionario externo, subcaracterísticas, es una matriz, una característica subcero, subcero y, luego, subpropiedades, sublat. Ahora puedes darte cuenta de eso e inmediatamente derivar esta cosa larga. Solo diré que cada vez que intento hacer eso, lo estropeo. Un pequeño error. Digamos que te perdiste esto. Cometeré un error aquí. Acabas de decir que tengo la primera entrada en largometrajes y voy a pasar al final. Eso significa que vas a ir directamente a Lat y vas a ver qué pasa entonces. Auge. Lo que dice es que no hay una latitud clave, y eso se debe a que estás en la función JS sub zero, sub lat. De nuevo, es fácil porque cometí el error. Este es el punto bajo cero y pensé que el Lat estaba en este objeto, pero no lo está. Tienes que ir a otro diccionario en lo profundo del diccionario de propiedades y luego puedes ir a lat. Por eso este funciona porque me sumerjo en las propiedades. Creo que puedo recuperarlo, ahorrarme algo de tiempo y ahora debería volver a funcionar. Estamos trabajando. Espero que te haya parecido interesante. La geocodificación es simplemente divertida. Más adelante en el curso crearemos un mapa y realizaremos una especie de geocodificación por lotes, usaremos una base de datos, etcétera, y luego crearemos un mapa. Eso es genial y puedes ubicarte en el mapa o en un lugar que conozcas del mapa. Espero que lo hayas disfrutado. Aplausos.