Así que estamos a punto de cerrar el círculo. Acabamos de crear muchas tablas de bases de datos , hemos dividido las cosas, las hemos vuelto a vincular todas con estos números. Y parece que acabamos de crear un lío con todo. Pero ahora estamos a punto de volver a unirlo todo con el JOIN. Por fin hemos tocado el poder relacional y puede parecer difícil, pero esto es importante, especialmente cuando los datos se escalan. Y si lo que está haciendo es importante, entonces los datos escalarán. No puedes decir: «Oh, mis datos son tan pequeños que no necesito hacer esto». Bueno, si lo haces, y es grande, y realmente te dedicas al análisis de datos, y es como algo que haces profesionalmente, no tiendes a hacer cosas pequeñas de forma profesional. Sueles hacer cosas grandes. Así que esta noción de claves principales y claves foráneas, y los pequeños números que apuntan a cosas, de eso se trata. Así que necesitamos reconstruir los datos de nuestra interfaz de usuario y volver a conectar todas estas conexiones. Y la sintaxis SQL que permite que esto suceda es la operación JOIN. Y el JOIN básicamente dice que estamos seleccionando datos de más de una tabla. Y parte de la operación JOIN es la cláusula ON que dice cuándo queremos conectar una fila y una tabla con la fila correspondiente de otra tabla. Y aquí tenemos este ejemplo de nuestros datos, en el que solo queremos extraer el título y el nombre del artista. Excepto que el título del artista está en el campo del álbum y el nombre del artista, porque lo hicimos de forma relacional, está en el campo del artista, por lo que no lo tenemos en un campo, por lo que tenemos que dividirlo en dos tablas. Ahí es donde decimos SELECCIONAR, y luego queremos las cosas. Esta es una sintaxis en la que tienes el nombre de la tabla, el nombre del campo, el nombre de la tabla.fieldname. La columna del título de la tabla Álbum, la columna del nombre de la tabla Artista, FROM , que es la misma columna FROM que hemos utilizado antes. Esta es una tabla unida a otra tabla. Y lo que estamos haciendo es decir: hagamos una supertabla que contenga realmente las filas de esta tabla, así como las filas de esa tabla, y eso es lo que hace la JOIN. Es como que no vamos a ir a una mesa, vamos a ir a dos mesas. Luego, además de la operación JOIN que indica que vamos a hacer todas estas tablas, la cláusula ON decide cuándo conectamos una fila de esta tabla con otra fila de esta tabla. Así que fila a fila, fila a fila y la cláusula ON que vamos a escribir es cuando el artist_id del álbum que viene de la tabla de álbumes, la clave externa, el principio de nuestra pequeña flecha, es igual al campo id de Artist, Artist.id, por lo que es el destino. Por lo tanto, este es el punto inicial de la flecha y este es el punto final de la flecha. Así que este es el comienzo. Este es el final. Esto es hacer coincidir, volver a conectar todas las flechas de todas las filas correspondientes. Selecciona estos dos campos, un campo de cada tabla, y luego uniremos las dos tablas, pero solo conectaremos las filas cuando esto sea cierto. Para mí, llamaría a esto cuando. Algunas personas prefieren escribir esto como una cláusula WHERE más larga, algunas bases de datos prefieren eso. Me gusta usar la cláusula ON, así que no confundo mis cláusulas WHERE. Pero si aprendes el truco de la cláusula WHERE, es lo mismo que el de la cláusula ON. Así que ejecutemos este. Eso ya está ahí. ¡Uy!. Así que lo dirigiré. Así que aquí voy. Tengo el título. ¡Uy!. Tengo el título de una tabla y el nombre de otra tabla. Y los unimos a todos. Y teníamos una cláusula de activación que decía cuándo deberían estar conectados. ¿Está bien? Así podemos analizar un poco más a fondo esta relación que tenemos, ¿verdad? Podemos, ya sabes, aclarar esto. Profundice un poco más en la relación que tenemos aquí analizando todos los datos que realmente intervienen en la conexión entre estas dos filas. Así que aquí tenemos una vez más nuestra cláusula SELECT, y nuestra cláusula FROM va entre álbum y artista. Así que, más o menos, esta es nuestra súper fila. De la tabla Álbum y la tabla Artista. Eso es Artist, eso es Album. Y aún tenemos la relación de Foreign Key. Y vamos a añadir a este SELECT estos dos campos. Todo es igual que antes, excepto que les mostraremos cómo se hace esta conexión, ¿de acuerdo? Así que vamos a seleccionar el título, el artist_id, el identificador del artista y el nombre. Así puedes ver cómo vemos toda la tabla en esta tabla. Estas cosas se han unido como si hubiera pegamento en el medio. Se han pegado juntas, y se pegan juntas en una situación en la que estas dos cosas coinciden. Así que si escribes eso, eso es lo que ves. Así que esa es la forma en que realmente no es necesario mostrarlos, pero son la fuente de la conexión. ¿Está bien? Esa es la fuente de la conexión, y con solo seleccionarlos, puedes ver qué aspecto tiene. Bien, construyamos otro. Supongamos que queremos el título de las pistas y el nombre del género. Y si echamos un vistazo a la canción, claro, tenemos genre_id. Ahora tenemos una réplica aquí. Y luego necesitamos hacer esta búsqueda, ¿verdad? Y queremos ver todas las pistas. ¿Verdad? Todas las canciones junto con sus géneros. ¿Verdad? Rock, rock, metal, metal. Así que ahora hemos reconstituido los duplicados. ¿Verdad? Esto es lo que el usuario quiere ver. Pero esto es lo que almacenamos en nuestra base de datos. ¿Está bien? Así que, de nuevo, decimos SELECT TRACK.TITLE. Esa es esta cosa. Género. Nombre. Es esa cosa de otra mesa. DE TRACK JOIN A GENRE. Eso hace que sea como una gran mancha que es una gran fila, que se extiende por dos mesas. Y luego tenemos la cláusula ON. Y uno pensaría que son difíciles de construir. Pero, oh, esta es la mesa Track. Hay un nombre de clave externa llamado genre_id. Ah, y será igual a tablename.id. ¿Verdad? Casi corto y pego estas cosas tan rápido como las escribo. Y así se vuelven cada vez más fáciles cuando pasas de la tabla de pistas a la tabla de géneros, y la sintaxis que utilizo para la conexión es muy canónica. Lo hago una y otra vez. ¿Está bien? Así que déjame dirigir a este tío y ahí vamos. Hemos reconstruido la réplica. Pero también es un buen momento para mostraros un poco más sobre lo que ocurre debajo de esta unión, ¿verdad? Y ahora todo parece bonito y simple con esta cláusula ON. Pero, ¿qué pasa si simplemente eliminamos la cláusula ON? Selecciona estas dos cosas de entre los tipos pegados. De alguna manera hemos pegado estas dos mesas juntas. Entonces, si no tienes una cláusula ON, lo que pasa es que básicamente dice todas las combinaciones. Todas las combinaciones. Así que hay cuatro filas aquí y dos filas aquí. Así que aquí está toda la combinación de cada fila. Así que esto se convierte en 2, esto se convierte en 2, así que se convierte en 8. Ahora, si esto tuviera 100, y este tuviera 100, serían 10.000. Así que si no tienes una cláusula ON, acabarás con todas las combinaciones. Y podemos demostrarlo. Así que esta es exactamente la misma instrucción SELECT. Track.title, genre_id, genre.id, vamos a añadir los elementos intermedios que habrían sido una cláusula ON. Y decimos FROM Track, JOIN con género y sin cláusula ON. Vale, eso es lo que ha cambiado. Añadimos estas dos columnas y eliminamos la cláusula ON. Así que echemos un vistazo a lo que ocurre cuando ejecutamos esta. Y las líneas no importan, así que el hecho de que ponga esto en varias líneas, verás, no me importa. Y así puedes añadir espaciados y líneas para que tu SQL se vea más bonito. Lo hago todo el tiempo, les hago una sangría. La sangría no tiene importancia, pero sigue siendo muy bonita. Así que ahora vemos que obtenemos todas las combinaciones. ¿Verdad? 1, 1; 1, 2; 1, 1; así que Black Dog tiene ambos géneros. Así que tiene el género 1 y el género 2. Porque no tenemos una cláusula ON, por lo que no le interesa hacer coincidir. Así que puedes pensar en un JOIN, puedes pensar en un JOIN como crear en ambas tablas todas las combinaciones posibles entre las tablas. La cláusula ON elimina las que no coinciden. O una forma mejor de decirlo es elegir las que coincidan, ¿verdad? Nos gusta esta combinación. Nos gusta esta combinación. Nos gusta esta combinación. Y nos gusta esta combinación. Eso es lo que hace la cláusula ON, seleccionar aquellas en las que hay una coincidencia. Si no tienes la cláusula ON, entonces boom. Todas las combinaciones, de 1 a 2. Esta es una fila y se está combinando con esa. Esta es la siguiente fila y queremos ambas combinaciones. Esta es la tercera fila, todas las combinaciones; la cuarta fila, todas las combinaciones y, a continuación, la cláusula ON borra las que no coincidan. Vaya, lo volví a hacer mal. Sigo haciéndolo mal, pero entiendes la idea. Así que esa es la cláusula ON. Así es como funciona realmente y, francamente, esta es una de las cosas que vi por primera vez, debe estar haciendo eso, pero no hace eso. Cuando ve la cláusula ON, es muy inteligente a la hora de incluir las cosas. Súper inteligente. Repito, ese no es nuestro problema. Así que ahora puede volverse complejo. Porque ahora lo que queremos es el título de la canción, el nombre del artista, el título del álbum y el nombre del género. Y esto parece un montón de cosas, pero si lo sigues, es un patrón. Así que tenemos un SELECT, estas son las cosas que queremos. Esa es la lista de los resultados que queremos. No nos interesan todas las identificaciones. Y tenemos que tener esta larga cláusula FROM, que dice: «Una canción con un género, una con un álbum, una con un artista». Son todas las filas, todas las tablas concatenadas, y luego la cláusula ON, que parece un poco complicada, pero ahora empezamos. Empezamos por Track y hacemos ejercicio. Tenemos la clave externa en Track si genre_id es igual a la clave principal del género. Y el album_id de la canción es igual a la clave principal del álbum, y hay una clave externa más: artist_id del álbum es igual a Artist.id. Así que volvamos a esa pequeña imagen en la que teníamos esto que apuntaba a esto, que apuntaba a aquello, que apuntaba a aquello. Solo miramos esto, la imagen, y por eso las imágenes son tan importantes, y reconstruimos todo esto. Así que esto, para mí, puede parecer un poco complejo. Pero después de hacerlo unas cuantas veces, te das cuenta de que la convención de nombres realmente te salva, ¿vale? Déjame mostrarte eso, selecciona todo este monstruoso lío. Escríbela y luego ejecútala. Y lo hemos reconstruido, ¿verdad? Bien, aquí tenemos la replicación, pero ese es el resultado. Esa es la belleza de las bases de datos: se reconstruye cualquier replicación, pero en realidad no se almacena la replicación. Y por eso hay que aprender a redactar cláusulas JOIN. Así que si pensamos en esto, hemos cerrado el círculo. Al igual que a cualquier empresa emergente , nos llevó unos tres días crear nuestro producto. Empezamos con una interfaz de usuario que diseñamos y que tenía replicación. Luego creamos un modelo de datos, un modelo de datos lógico, luego un modelo de datos físico, luego insertamos todos los datos, conectamos las cosas con números en lugar de cadenas. Y ahora usamos un JOIN para reconstruirlo. Y así, empezamos aquí. Damos un paso, un paso, un paso y, luego, volvemos aquí y podemos reconstruir, en efecto, el resultado que nuestros usuarios finales querrán ver. Solo que ahora podemos gestionar millones o miles de millones de filas, porque hemos creado cuidadosamente un modelo de datos que tiene sentido.