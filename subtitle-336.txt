Hola a todos y bienvenidos a Python for Everybody. Vamos a hacer algunos tutoriales de código. Sin embargo, si quieres el código de muestra, puedes descargar el zip de nuestro sitio web. El trabajo que estamos haciendo ahora es crear una herramienta de visualización visual y de araña para los datos de correo electrónico que provienen originalmente de este sitio web gmane. Pero tengo mi propia copia. Entonces, lo que hicimos antes fue ejecutar gmane.py y obtuve una URL. Tengo una URL con todos estos datos, la descargué y luego volví a ejecutar gmane para ponerme al día. Me llevó bastante tiempo ponerme al día, pero para cuando llegue a... Recuerda que dije que corre, intenta fallar cinco veces. Bueno, se quedó sin datos en 60.421 y luego empezó a fallar y luego se cerró. Así que ahora tenemos prácticamente todos nuestros datos. Tenemos todos... Hemos terminado este proceso y el contenido de S es SQLite, ¿de acuerdo? Y si echo un vistazo al navegador de la base de datos, podemos ver que tenemos 59.823 mensajes de correo electrónico. Así que, si miro cualquiera de estas cosas, verás los encabezados, verás la línea de asunto, verás la dirección de correo electrónico, verás el cuerpo de la misma. Recordad que dividí el texto en dos partes y luego las cabeceras y así fue. Lo hice lo más crudo posible porque, como habréis visto, tuve que pasar mucho tiempo en el gmane poniendo los datos recuperados correctamente. Por eso, no me gusta limpiar demasiado los datos. Por lo tanto, lo que veremos a continuación es el proceso de limpieza de datos. ¿Está bien? Entonces, esto es gmodel.py, es lo que vamos a ver ahora. Así que deshagámonos de esos tipos y echemos un vistazo a gmodel.py. No creo que necesite url lib en este código. ¿Tengo alguna URL? ¡No!. Así que no lo necesito. Lo siento. Lo arreglé. Está bien. Así que va a leer de la base de datos, tiene un registro de llamadas, va a usar expresiones regulares. Y zlib es una forma de hacer algunas compresiones, así que voy a hacer: En esta, voy a comprimir algunos de los datos para que tenga menos datos; algunos de los campos de texto se comprimirán. Quería mantener estos campos sin comprimir dentro de los mensajes. Entonces, tenemos algunos mensajes que limpian y limpian las cosas y resulta que la forma en que las direcciones de correo electrónico, en este corpus de correo en particular, cambiaron con el tiempo y nosotros... hay ciertos tipos de cosas. A veces, gmane.org es la dirección de correo electrónico cuando la gente quiere ocultar su dirección. Hice todo tipo de cosas, las dividí y comprobé si terminaban así, y limpié las cosas, solo eso y nada. Y por eso, tengo todo tipo de cosas de limpieza aquí. Me dedico al mapeo y al mapeo de DNS, de lo que hablaré más adelante, donde las organizaciones a veces enviaban correos electrónicos con diferentes direcciones a lo largo del tiempo, y las personas enviaban correos electrónicos desde diferentes tiempos parciales. Y vamos a analizar la fecha y ese es el código para ello. Vamos a extraer la información del encabezado. Esto está en cierto modo tomado del otro código. Limpiaremos las direcciones de correo electrónico y los nombres de dominio. Y extraeremos los datos, extraeremos el asunto, extraeremos el identificador del mensaje, varias cosas. Así que aquí está el cuerpo principal del código. Vamos a pasar de Content.sqlite a Index.sqlite. Y lo que voy a hacer cada vez es borrar Index.sqlite y colocarlo en los mensajes, remitentes, asuntos y respuestas. Así que esta es una base de datos normalizada y tiene claves externas. Por lo tanto, aquí hay una tabla de mensajes con la clave principal entera, su identificador. GUID son las siglas de Global Unique ID, en inglés, sen times , sender ID, y luego tendrá un blob. Estos son blobs, objetos binarios de gran tamaño, para los encabezados y el cuerpo, porque voy a comprimirlos en esta base de datos para crearlos. Y luego los remitentes, cada remitente tiene una clave, y luego los asuntos, cada línea de asunto va a tener una clave y, por último, las respuestas son una conexión de un mensaje a otro, así que esto es como de muchos a muchos. Ahora, también tengo este archivo llamado Mapping.sqlite. Y entonces, podemos echarle un vistazo a ese: Mapping.sqlite. Y entonces, lo que pasó es que hay dos mesas con las que trato a mano. Así que, a veces, Indiana... esta era una dirección de correo electrónico que correspondía a esa dirección. Así que Indiana.edu, esa es una forma de tomar... esa es la dirección de correo electrónico. Y luego había un grupo de personas cuya dirección de correo electrónico cambiaba a lo largo del proyecto y yo, en cierto modo, las mapeé de alguna manera. Y entonces, esto es algo así como... lo saqué muy rápido, y leí todo esto del mapeo de DNS y, aparte de quitarlo y ponerlo en minúsculas, etc., simplemente voy a hacer un diccionario. La asignación de DNS, que es el nombre antiguo al nombre nuevo, y la asignación de direcciones de correo electrónico del nombre antiguo al nombre nuevo, y luego fixsender. Fixsender se debe a que la dirección de correo electrónico está incluso dentro de gmane, somos un poco curiosos. Así que no te preocupes demasiado por esto. Está bien. Así que, ahora lo que voy a hacer es abrir una conexión solo para leer todas esas cosas y ahora voy a abrir el contenido principal. Y estoy pidiendo que se abra, esto es un poco más complicado. Lo abro solo de lectura. Eso me permitía manejar la araña y la otra al mismo tiempo. Me sale un cursor. Así que voy a leerlo todo, así que en el archivo de contenido, este es el más grande, voy a leer y revisar cada uno de ellos y escribir en él todas estas cosas. Tomaré todas las direcciones de correo electrónico y las pondré en una lista. Así que lo cargué. Tengo los mapas cargados. Y ahora voy a revisar todos los mensajes. Tengo todos los remitentes, todos los asuntos y todos los identificadores únicos globales. Así que leo cada mensaje, así que ahora reviso el contenido uno por uno. Analizo los encabezados. Compruebo si el nombre y la dirección de correo electrónico del remitente, una vez limpiados, están en mi mapeo, mapping.getsender, y el valor predeterminado es como el remitente inverso. Así que eso es lo que está diciendo. Busque el remitente, si está ahí, deme la entrada de esa clave. Si no, devuélvela. Vamos a imprimir cada 250 cosas que hagamos. Nos quejaremos si es cierto. Vamos a buscar el mapeo entre los remitentes, que es una forma de buscar la clave principal. Podría haberlo hecho con una base de datos, pero quería que fuera rápido. Esa es parte de la razón por la que leo todas estas cosas para poder hacer esos mapeos muy rápidos. Verás que esto lleva un poco de tiempo a pesar de que , ya sabes, tengo todo en caché. Entonces, si no tengo un identificador de remitente, es decir, no lo he visto todavía, lo insertaré o ignoraré en los remitentes. Y luego voy a hacer una selección, y ya habéis visto esto en el que cojo la fila hacia atrás y solo intento ver el identificador que se me ha asignado recientemente. Y luego, no solo configuraré el ID del remitente para este bucle de iteración, sino que también lo guardaré en el diccionario para construir este diccionario. Y verás que lo mismo ocurre con el ID del sujeto. Lo insertaré en la tabla de asuntos y obtendré una clave principal si no sé cuál es. Y luego lo voy a poner, no solo en la base de datos, sino que también lo voy a poner en mi diccionario. Y lo mismo... Supongo que no lo hice por el gremio. Está bien. Ahora lo que tengo son el ID del remitente y el ID del asunto, que son claves externas en la tabla central y en la tabla de asuntos, y voy a insertar el mensaje con el ID del remitente, el ID del asunto, los encabezados y el cuerpo del mensaje enviado. Y los valores que aparecen aquí son el identificador del remitente, el asunto y el destinatario. Ahora, esto aquí, zlib.compress. Lo que tomo es el mensaje, el encabezado y el cuerpo, y esta pequeña parte termina con la versión comprimida de todo esto y lo verás en un segundo. Y esto reduce el tamaño de estos elementos de texto a costa del cálculo de. Tenemos que analizar el costo del cálculo para comprimir y descomprimir cuando queremos leerlo. ¿Está bien? Y luego saco la guía, la ID, que es la guía, y saco la clave principal de esta cosa basada en la guía. Y actualizo este diccionario. ¿Está bien? Así que permíteme ejecutar ese código. Está limpiando mucho, y te diré que me llevó mucho tiempo hacer que esto funcionara. Así que... este código que estoy ejecutando ahora, oh, jajaja. No olvides usar un Python3, Chuck. Así que esto se ejecutará cada 250. Así que hizo todo este almacenamiento previo en caché. Así que ese es el tiempo que se tarda en hacer 250. Otros 60.000 aquí. Por lo tanto, esto está muy ocupado. La razón por la que va y viene es que cada vez que crea este archivo de diario, es y luego hace una confirmación. Así que te das cuenta de que está ocupado creando archivos de diario y comprometiéndose, y hay mucha actividad aquí. Resulta que Adam me muestra estos archivos. Vale, pues está acabado. Tardé unos tres minutos en terminarlo. ¿Verdad? Entonces, si echamos un vistazo al tamaño de los archivos, veremos que el índice es mucho más pequeño. Está completamente normalizado. Sigue siendo de 263 megabytes. Está todo comprimido. Así que echemos un vistazo a eso en el navegador. Así que son 200 megabytes, pero se carga mucho más rápido. Ahí vamos. Así que tenemos una tabla de remitentes, ¿verdad? Lo cual es una especie de mesa de varios a uno. Tenemos una tabla de temas a tratar, que es una mesa de muchos a uno. Y tenemos mensajes que tienen claves foráneas y se tarda un poco en cargarlas. Está bien. Y así, vemos las claves foráneas del remitente y el asunto y eso nos salva, todas esas claves foráneas nos salvan. Y así tenemos, como pueden ver, que no puedo ver los encabezados en el cuerpo porque ahora están comprimidos. Eso me ahorra un montón de cosas, ¿verdad? Me ahorró un montón de cosas. Ya sabes, entonces, eso es lo que hay en ese archivo. Y que hemos terminado este proceso. ¿Está bien? Hemos terminado de modelar los datos y hacerlos realmente limpios, y volveremos a empezar y el resto de lo que haremos será visualizar y extraer datos de Index.sqlite. La idea es que esto se pueda reiniciar. Esto se puede ejecutar una y otra vez aunque lleve unos tres minutos ejecutarlo. Es mucho mejor que ejecutar esto en cinco horas. Así que tres minutos, cinco horas y ya verás, y ya veremos ahora leyendo esto, como en segundos, porque lo tenemos todo bien y normalizado de una manera bastante bonita. Así que espero que esto haya sido útil. En la próxima, haremos la visualización.