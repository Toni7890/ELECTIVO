[MÚSICA] Hola a todos, bienvenidos a Python for Everybody. Estamos haciendo un pequeño tutorial del código. Si quieres seguir los pasos, puedes descargar el archivo ZIP del código desde nuestro sitio web. Estamos recuperando datos de este servidor de gmane, del que hice una copia. Y hasta ahora lo hemos rastreado todo y hemos acabado con 600 megabytes de información escaneada. Hemos llevado a cabo un proceso de limpieza bastante complejo que probablemente no necesites entender completamente. Puedes buscarlo en busca de patrones, pero en general, el proceso de limpieza será muy sensible a los datos. Y luego tenemos este index.sqlite, que ahora ocupa 260 MB. Y ahora vamos a hacer las partes fáciles, divertidas y fáciles, en las que vamos a ejecutar pequeñas consultas que simplemente extraen datos. Así que estas son mucho más sencillas. Así que parte de lo que escribí cuando estaba haciendo esto era que quería hacer algunos cálculos básicos sencillos con los datos para asegurarme de que realmente estaba buscando anomalías, ¿verdad? Qué funcionaba y qué no funcionaba, así que escribí una serie de cosas muy sencillas, como esta básica. El código básico solo para darme algunos datos básicos, ¿verdad? Así que escribí las cosas y las conté, así que, ¿necesito urllib para cuestionar esto? No lo creo, arreglemos ese error, no existe, no hay razón para poner nada de eso ahí. Así que dice eso: index.sqlite, que son nuestros datos limpiados. Lo lee todo y crea un diccionario, este patrón lo van a ver mucho en el que voy a hacer un diccionario de identificación para Senders. Ahórrate mirar cosas repetidamente. Voy a coger los temas, los he guardado todos en caché. Podría haber hecho todo esto con SQL, pero solo quería hacer las cosas más rápido. Y ahora voy a revisar cada uno de estos mensajes y crear un diccionario con ellos. Voy a guardar muchas cosas en la memoria. Y luego voy a hacer algunos recuentos. Voy a ver quién ha enviado más, sí, las organizaciones. Y ahora tengo que revisar todos los mensajes. Así que te darás cuenta de que aquí no selecciono el cuerpo ni los encabezados. Acabo de recibir sender_id, subject_id, probablemente podría haberlo hecho con una unión, habría sido más limpio. Eso, puedes hacer eso, puedes hacer ese cambio. Hazlo con una junta para que quede más limpio. Así que voy a leer todos los mensajes, excepto el cuerpo, así que esto va a ser muy rápido. Saco el identificador del remitente, lo rompo en pedazos, veo que mis datos están limpios, lo he limpiado todo en los procesos anteriores. Y si no tengo dos partes, continúo y obtengo el nombre de dominio. Así que tengo a la persona. Estoy haciendo un histograma de diccionario básico para las personas y los dominios. Y luego los voy a ordenar, sí, con un orden. Y vamos a coger la llave. Vamos a ordenarlo por el número de personas al revés, y luego imprimiremos las mejores organizaciones y las personas más destacadas, ¿de acuerdo? Así que simplemente ejecutaremos ese código. python gbasic.py, escribamos para eliminar los 10 primeros. Así que subimos 59.000 mensajes, 29.000 temas y 1.800 remitentes y determinamos cuáles eran las 10 personas y las 10 organizaciones principales. Y puedes escribir varias cosas así, como si fueran una especie de pantalla entre tus datos. Y es bueno que compruebes tus datos, ¿vale? Así que eso es básico, ahora quiero usar gword.py, porque es bastante divertido. gword.py, no necesito urllib, ¿por qué sigo poniendo urllib en todas estas cosas? Así que me desharé de eso. Así que esto es muy simple, porque voy a usar las palabras de la línea de asunto. Así que reviso index.sqlite. Leo en todas las asignaturas. Y hago un diccionario de ellas. Y luego voy y busco todos los temas. Y luego hago este código aquí mismo. Voy a sacar el asunto basándome en el mensaje. Y lo hago para que cuando los temas se usen más de una vez, cuente las palabras más de una vez. Esto es str.maketrans, hablé de eso en un capítulo anterior. Básicamente, esto elimina la puntuación y los números, de modo que cuando formo mis palabras no termino con palabras que parezcan guiones. Los comprime. Luego lo quito y lo convierto todo a minúsculas. Esto es básicamente para evitar que aparezcan demasiadas palabras. Luego hago una división, y luego tengo cuentas, un diccionario. Así que este es un diccionario sin puntuación ni números. Y luego cojo la [TOS] y uso un diccionario. Y luego los clasifico en orden inverso. Y luego averiguo cuál es el valor más alto y el más bajo analizando a, probablemente podría haber hecho esto con un máximo y un mínimo si me hubiera dado la gana. Y ahora tengo el más alto y el más bajo. Sabes, debería haber hecho un máximo y un mínimo en eso. ¿Por qué hice eso? Pero, bueno. Y ahora tengo que distribuir el tamaño. Y por eso voy a producir este archivo gword.js, que es necesario para la visualización. porque va a usar d3.js, un visualizador de palabras, y gword.js. Tengo que decirle qué tan grande es el texto, así que voy a normalizarlo un poco. Me llevó un poco de experimentación. Así que si ejecuto esto ahora, y digo python gword.js, y digo python3 gword.js, que es mucho mejor. No, Python. Bien, ahora puedo ir a ver el archivo gword.js, donde quiera que esté, gword.js, sí. Básicamente, normalizó todas las frecuencias y creó el tamaño de la fuente. Estos son los tamaños de fuente ahora, ¿vale? Estos son solo los datos que necesita este gword.jm, que usa este código de nube de palabras de visualización 3D. Así que esto extrae todos mis datos, y luego esto es solo un JavaScript que dibuja la imagen en la página, ¿de acuerdo? Así que la parte más fácil ahora es simplemente abrir gword.htm en un navegador. Da la casualidad de que en un Mac puedo hacer esto. Y eso me da una nube de palabras basada en esos datos y, en cierto modo, los distribuye aleatoriamente. Muestra cosas diferentes, pero usa esto, usa estos datos para generar el tamaño de esas cosas y, luego, usa un poco de aleatoriedad y recocido simulado para diseñarlas. No es algo de lo que tengamos que preocuparnos, ¿vale? Así es como llegamos al punto en el que vemos una nube de palabras a partir de esto. Ahora, vamos a hacer otra visualización. Y esta vez vamos a hacer una visualización lineal. Y vamos a crear algo llamado gline.js y producirlo con otro archivo HTML. Vamos a usar d3 y producir ese resultado. Así que vamos a despedirnos aquí. Adiós, adiós, adiós, adiós. Así que gline.py, deshazte de ese archivo [COUGH]. Así que, de nuevo, voy a precargar todos los remitentes en este caso. Y repito, podría haberlo hecho con la unión, probablemente debería haberlo hecho con una unión. Voy a precargar todos los mensajes. Los sender_id, subject_id, etc. Y los cargaré. Y ahora que voy a leerlo, voy a ver las organizaciones de envío y los remitentes. Y dividiré los remitentes y tendré las organizaciones de envío. Y luego voy a crear un diccionario sencillo a medida que acumule las organizaciones de envío dividiendo los nombres de las personas en letreros. Y luego, basándome en la organización, lo acumulo. Y luego los clasifico. Y selecciono las 10 mejores organizaciones. Imprímelos y dividiré esto en meses. Y les mostraré cómo se ve esto en un segundo, vayamos al gline.js. Así que el mes se ve así. Vale, así que el mes se ve así. Así que esos son los primeros siete caracteres de la fecha. Entonces, si miramos la fecha, la fecha se ve así, y el mes son los primeros siete caracteres. Y estos son los datos que tengo que darles. Los limpiaremos en un segundo, esos datos se verán mejor en un momento. Vuelva a gline.py. Estamos haciendo una, la clave es una tupla, cuál es el mes y qué organización es la que lo hizo. Y solo está entre las 10 mejores organizaciones, y luego vamos a hacer un, básicamente, vamos a hacer un diccionario donde la clave es una tupla. Y luego vamos a ordenarlo, ordenándolo por clave en este caso, no por valor. Eso es dentro de unos meses, vamos a solucionarlo. Y luego vamos a escribir todos estos datos en gline.js, así que sigamos y ejecutemos esto. Y de nuevo, estos son solo los datos que deben escribirse de manera que JavaScript pueda entenderlos. python3 gline.py, vale, así que las 10 mejores organizaciones. Así que ahora echemos un vistazo a ese JavaScript. Así que esto es lo que parece. Así que resulta que tienes que decir que estos son los puntos de datos, estas son las líneas. Así que este es el Año, la línea de la Universidad de Michigan, gmail.com, swinsborg.com. Así que esta primera columna son los puntos de la línea y los puntos de la línea siguiente. Así que todo este código consistía en obtener los datos de tal forma que pudiera producir este archivo JavaScript. Porque si miro gline.htm, necesito esos datos en ese formato en particular. Y tengo todas estas cosas. Hago un gráfico de líneas. Lo dibujo con estos datos. Con esos datos, tuve que ir a leer toda la documentación sobre cómo averiguar estas cosas. Y esos son los datos que voy a usar. Y tenía que averiguarlo. Tuve que transformarlo y hacerlo bonito. Me llevó bastante tiempo hacer que esto funcionara. Y esta no es una clase de JavaScript, ni una forma de visualizar en 3D. Pero, básicamente, recogimos todas esas cosas, y aquí está la línea gline que proviene de JavaScript y luego crea un ArrayToDataTable. Y luego esa tabla de datos es lo que dibuja gline. Así que sin más preámbulos, abramos gline.htm para mostrar esos datos. Así que ahí lo tienes, esa es la participación de los desarrolladores de Sakai entre 2005 y 2015, según las organizaciones que realizaron el mayor número de compromisos con Sakai. Así que sé que no le he hecho justicia a todo este código, hay mucho código aquí. Lo divertido es simplemente ejecutarlo y verlo. Y luego, cuando llegue el momento, volver y ver las técnicas que se utilizan cuando intentas crear tu propio canal de visualización. Así que espero que esto te haya resultado útil. Es mucho código, difícil de explicar en 15 o 20 minutos, pero espero que te tomes un tiempo y lo revises. Espero que hayáis encontrado todos estos vídeos, este es como el último vídeo explicativo del capítulo 16 del libro, así que espero veros en la red. [MÚSICA]