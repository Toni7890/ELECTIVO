Hola y bienvenidos al capítulo cuatro. Ahora, volveremos a ver lo que mencioné en el primer capítulo del cuarto patrón de código. Iteraciones secuenciales, condicionales, y luego almacenar y reutilizar. Este es el patrón de almacenar y reutilizar, y la esencia básica del patrón de almacenar y reutilizar es que a nosotros, como programadores, no nos gusta repetirnos. Así que, si tienes como cuatro líneas de código y quieres hacer lo mismo más adelante, ponlo aquí. Y luego, lo pones más tarde. ¿Y qué pasa si encuentras algún problema con esas cuatro líneas de código? Luego tienes que encontrar todos los lugares y, digamos que lo pones en 100 lugares en tu programa. Tienes que encontrar los 100 lugares y corregir el error. Entonces decimos, bueno, ¿por qué no ponemos ese lugar y le damos un nombre, y luego lo usamos en todos los demás lugares? Y eso es exactamente lo que significa almacenar y reutilizar. Es la idea de no repetirte, D-R-Y, no te repitas. Esto es lo que tenemos aquí, pasos almacenados y reutilizados. Y las funciones son aquellas cosas que almacenamos y reutilizamos. Así que echemos un vistazo. Así que la nueva palabra clave que tenemos es def, d-e-f, que significa iniciar la definición de una función, definir la función. def es la palabra clave, termina en dos puntos, al igual que muchas cosas que comienzan con un bloque indentado. Así comienza un bloque indentado. Obtienes el nombre de lo que estás almacenando, yo lo llamo cosa por ahora, y hay algunos parámetros opcionales, que veremos más adelante, entre paréntesis. En este momento, no tenemos parámetros en esta función, y hay un bloque indentado, y luego, cuando eliminas la sangría, eso define la función. Muy bien, esta cosa ha sido desindentada, pero también esta t está desindentada y esa es la definición del final de la función. Ahora bien, es clave entender que, dado que Python lo analiza o analiza, en realidad no se ejecuta. Ahí hay dos sentencias ejecutables, print e print. Pero lo único que hace es recordarlo. Así que lo almacena en un área pequeña casi como una variable, sí, como una variable x = 2. Bueno, hay una x ahí fuera y le pones un 2. Bueno, hay una cosa ahí fuera, t-h-i-n-g. Y tiene dos líneas de código. Así que es como una variable, excepto que contiene código. Vale, entonces una función es como una variable, excepto que contiene código. Y lo que es más importante, no ejecuta estas líneas de código. Así que, si no hay salida, no hay salida aquí. No sale nada de esa primera parte. Ahora bien, tiene el efecto secundario de extender Python, así que hay una nueva cosa, «cosa», que podemos llamar. Así que a esto lo llamamos llamar o invocar. Así que hemos creado una de estas cosas, ahora llamémosla. Así que decimos cosa (). Y esa es la sintaxis para decir go call the function. Ahora que hemos estado usando funciones, imprimir es una función, ¿verdad? parámetro print (), así es como funciona la impresión. Bueno, la cosa es una función , thing (), pero resulta que no tiene ningún parámetro porque es una función muy simple. Entonces, lo que pasa es que def no hace más que recordar cosas, y luego dice: Oh, volvamos atrás y ejecutemos esa cosa, repasemos esas dos líneas. Así que salen Hello and Fun. Y luego vuelve a aquí, publica esta declaración impresa, y sale Zip. Y luego dice: «Oh, ejecuta ese código otra vez». Así que esta es la parte de no repetirte. Ejecuta esto, imprime, imprime, vuelve a hacerlo y ahora el programa está listo. Así que vuelve aquí. Así que una de las cosas de las funciones es que Python, cuando llama a una función, recuerda de alguna manera a dónde volver. Es como, está bien, sube aquí. Ahora que terminé, ¿a dónde voy a volver? Oh, me acordé de volver aquí, así que haz esto. Ok, este es mi lugar de regreso, corre, vuelve al lugar de regreso. Así que es como pausar este código, hacer una pausa aquí, ejecutar esto y luego reanudar allí. Así que es como saltar y luego volver. Así que hemos estado usando funciones desde el principio, cosas como print, input, type, float, int. int y float para hacer conversiones, escribir nos dice qué tipo de cosa es algo, imprimir imprime cosas y input lee cosas del usuario. Más adelante hablaremos de las funciones que crearemos y usaremos. A medida que ampliamos Python mediante la creación de funciones, podemos pensar en ellas como nuevas reservas o nombres de funciones. Por lo tanto, las convenciones de nomenclatura para los nombres de las funciones son las mismas que para las variables, por lo que conviene evitar cosas como las palabras reservadas y otras cosas por el estilo. Por lo tanto, la función es un fragmento de código reutilizable, definimos una función con una palabra clave def y, a continuación, la llamamos o la invocamos. La mayoría de las veces decimos llamar, pero creo que invocar es un poco más claro. Al igual que invocar esta función, hágalo bien, aquí con un nombre de función, paréntesis y luego argumentos opcionales. Así que aquí hay una función con la que aún no hemos jugado llamada función max. También es otra de las funciones integradas de Python y este es un ejemplo de argumento. Pasamos una cadena y le pedimos a Max que encuentre lo más grande de algo y, en este caso, escaneará esta cadena y encontrará la letra más grande. Y decide que w es la letra más grande. Aparentemente, las letras minúsculas son más grandes que las mayúsculas. Y luego hace lo que se llama un retorno y nos devuelve lo que es como, me pediste que encontrara esto y ahora encontré una w. Aquí tienes y entonces esa w se asigna a grande. Así que si hacemos un min, que es una función diferente, lo pasamos en el mismo mundo de Hello, busca la cosa más pequeña. Y por alguna razón, el espacio es lo más pequeño. Así que este espacio es lo que se devuelve a Tiny, y hay un espacio justo ahí y allá vamos. Así que, en algún nivel, puedes pensar en esta función máxima como un fragmento de código que ya se ha integrado en Python anteriormente. Estamos pasando un argumento, que es una cadena. Aquí hay un código que se ejecuta, lee el argumento, entra y luego lee y mira esas cosas, lee algunas cosas y luego nos devuelve la respuesta, que es w, que es lo que se llama return. Nos devuelve algo. Y luego esa w, así que crees que funciona en este lado de esta declaración de tareas. La w es el valor residual, una vez que se ejecuta la función max. Y luego eso se asigna a grande, y así de grande tiene la letra w. Así que el tipo de cosas con las que hemos estado jugando hasta ahora son las conversiones de tipos. Y aquí está Python, viendo qué imprimir. Es como: oh, tengo una expresión aquí, pero espera un segundo, quiero hacer esto, pero espera, oh, tengo que llamar a una función. Así que hay un pequeño flotador aquí, un pequeño código para flotar. Pasamos un 99 y obtenemos 99,0 y luego ese 99,0 dividido por 100 nos da 0,99. Así que hace una pausa en su cálculo y, luego, ejecuta este código flotante y luego regresa. Ahora vamos a hacer que una variable i, 42 diga qué tipo de cosa es, es un número entero. Ahora, lo que vamos a hacer es pasar este número entero al mismo código flotante, 42 al mismo código flotante, y saldrá 42.0 y eso reemplazará esto en la función y se asignará a f. Y entonces, sorpresa, sorpresa, tenemos 42 en f, preguntamos qué tipo de cosa es. Y luego, va a hacer este cálculo. Recuerda que primero hará la multiplicación y la segunda, así que calculará dos veces el valor flotante. Oh, espera un segundo. Pare un momento. Ahora tenemos que ejecutar float, lo que significa que tomamos este 3 y lo pasamos al código flotante. El flotante nos devuelve, en este caso, 3.0, que lo reemplaza en la función por 3.0. Y luego terminamos con este cálculo de 2 veces 3.0 o 6.0 y así sucesivamente y el resto termina. Pensáis que estas llamadas a funciones suspenden lo que estamos haciendo, solo por un breve instante, suspenderemos eso y esperaremos, y luego la función nos devolverá algo para reemplazarlo, ¿de acuerdo? También son conversiones de cadenas. Hemos estado usando int y float para hacer cosas como leer cosas porque la entrada es una función pero siempre nos devuelve una cadena. Y nos da una cadena. Podríamos usar esto como un número. Así que la cadena 1-2-3 no es lo mismo que 123. Es una cadena. Y si hacemos algo loco como agregarle 1, Boom, obtenemos un rastreo porque no podemos concatenar una cadena y un entero solo porque son del tipo incorrecto. Pero si tomamos este mismo 123, tenemos un pequeño código llamado función int. Pasamos sval, que es 1-2-3 de la cadena, y obtenemos 123 como número entero, que sustituye a este en la función y, a continuación, se asigna 123 enteros a ival. Y decimos: oye, ¿qué tipo de cosa es rival? Bueno, es un número entero. Podemos agregarle 1 y obtener 124. Acabamos de llegar de un capítulo anterior, si llamáramos a un int y le pasáramos hola bob , debería haber usado un color diferente. Pasamos la palabra «Hello Bob». Este código explota. [SONIDO] Y dice oh, rastreo, y explotó. Así que incluso una función puede explotar. ¿Y sabes qué? Nuestro código explota. Así que la función explota y nos vamos. A continuación vamos a dejar de usar funciones integradas y, de hecho, definiremos y usaremos algunas funciones propias.