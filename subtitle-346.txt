Así que ahora vamos a crear algunas de nuestras propias funciones. En cierto modo, vimos un poco de esa sintaxis desde el principio. Vamos a explorar el uso de la palabra clave def y algunas de las decisiones que podemos tomar. Entonces, la esencia de esto, la diré probablemente 20 veces. La instrucción def solo define la función. Tiene un efecto secundario, pero en realidad no ejecuta el código. Simplemente recuerda el código y, más adelante, llamaremos e invocaremos la función. He aquí un ejemplo de código disfuncional que no va a funcionar muy bien. Y así que entramos aquí, establecemos x = 5. Y no es necesario tener la definición al principio del programa. Hacemos una declaración impresa, así sale Hello. Y luego hacemos una declaración definitiva y eso pasa por aquí. Y el resultado es que has extendido Python para tener esta cosa llamada la función print_lyrics, y aquí tiene dos bits de código. Ahora, esta impresión elimina la sangría, así que eso lo bloquea. Esa pequeña parte dentro del bloque es la función, esas cosas se han copiado hasta allí, y ahora continúa e imprime Yo. Y agrega 2 a x y luego imprime x, y sale un 7 y ahora el programa está listo. ¿Qué pasó con estas líneas de código? Y la respuesta es que nunca se ejecutaron, nunca se ejecutaron. Y eso se debe a que la instrucción def no ejecuta automáticamente el código. Debes invocar. No hemos invocado la función. No estoy seguro de si es una cara feliz o triste, es una cara irónica, es una cara que se pregunta qué está pasando. Así que no lo invocamos, ¿verdad? No lo invocamos, por lo que no funcionó y no obtuvimos ningún resultado. Ahora, ¿por qué lo hicimos? No sé por qué lo hicimos. Signo de interrogación, signo de interrogación. Quién sabe por qué hicimos esto. Pero lo que realmente queríamos hacer probablemente fuera algo que se pareciera más a la próxima parte. Una vez que lo definamos, tenemos que llamarlo, y esa es la parte de reutilización. Teníamos la parte de la tienda funcionando, pero no la parte de reutilización. Así que aquí vamos, este es un código un poco más funcional. Pon x en 5, imprime hola, sale eso viene. Defínalo, esto no generará ningún resultado, pero la supresión de la sangría hace que este bloque forme parte de eso, y ya está almacenado. Tienda. Ahora imprimimos Yo, y así sale Yo. Y luego llamamos a print_lyrics. Y de nuevo, print es una función, tiene paréntesis con parámetros. Tiene paréntesis sin parámetros. No hemos introducido ningún parámetro, lo veremos en un segundo. Print_lyrics ahora dice: oh, ejecuta este código. Así que salen estas dos sentencias impresas, luego sumamos 2 a x, las imprimimos y obtenemos 7. Así que esta es la tienda, esta es la reutilización, esta es la llamada, esta es la invocación. ¿Vale? Está bien. Así que todo lo que hemos mostrado hasta ahora no tiene argumentos, excepto que este máximo sí tenía un argumento. Ese máximo se introduce y luego obtendremos algo, la w, y luego la w quedará atrapada en grande. Así que los argumentos son datos de entrada, así que si queremos definir los argumentos en las funciones que estamos creando, simplemente los ponemos entre paréntesis. Ahora es como una variable, elegimos el nombre de la variable. Pero esta variable en cierto modo no existe. Esta variable lang se considera mejor como un alias. Es un alias para el primer parámetro que vaya a ser cuando se invoque esa función en particular. Vamos a invocar esta función tres veces, vamos a poner entre paréntesis tres cosas diferentes. Esta es una forma de tener un código que es casi igual pero un poco diferente. Al introducir diferentes parámetros, el código hace algo diferente. Así que esto en realidad es solo un marcador de posición para decir lo que sea el primer parámetro. Si ese primer parámetro es es, imprima esto. Si ese primer parámetro es fr, imprímalo. De lo contrario, imprima eso. Así que. A medida que nuestro programa se ejecuta, esto no logra nada, no ejecuta ningún código, pero crea una cosa llamada greet ahí fuera. Y le hemos indicado a Python que esperamos un parámetro. Esperamos que cuando se invoque o llame a esto, queramos un parámetro. Entonces llamamos greet y, de nuevo, Python se acuerda de volver aquí. Y luego se activa hasta aquí y comienza esta línea de código. Y en, lang es un alias para en. Así que es como que lang no es es, lang no es fr, así que este código se ejecuta, sale Hello y listo. Y dice: «Regresa al lugar donde recordaste que ibas a recoger a continuación», que es aquí. ¿Vale? Así que dice que recogerás a continuación. Luego pasa a la siguiente declaración, saludo. Así que volverá a ejecutar esta función. Recuerda a dónde volver, que está justo aquí. Salta hasta aquí y haz que esta vez sea lo que significa lang. Así que ahora, lang es es, así que esto es cierto. Ejecutamos ese código, salimos e imprimimos Hola y luego volvemos a donde lo recordamos antes. Luego continuamos, llegamos a este código, ¿de acuerdo? Ahora que estamos en este código, es hora de volver a saludar, así que saltamos hasta aquí. Y esta vez fr es lang, así que sale aquí, eso es falso, esto es cierto, así que lo imprime, imprime Bonjour. Luego viene y recuerda. Oh, olvidé recordar adónde volver y continúa, ¿de acuerdo? Así que ves todo el patrón ahí, un montón de bonitos colores diferentes, pero entiendes la idea. Que se ejecute un par de veces y lang sea el alias del primer parámetro. Y esa es la mejor manera de pensarlo. Sea cual sea el primer parámetro, usaré lang aquí, usaré lang para referirme al primer parámetro. Puedes ponerle un nombre a esta cosa, no hagas esto, pero puedes llamarla p1, p1, p1. Así que al parámetro uno, no, a Python no le importaría, pero en realidad es solo el primer parámetro. Lang en sí no es realmente una variable, ya que no hay ningún fragmento de memoria al que pertenezca lang. En realidad, es como un alias de otra cosa. ¿Vale? Está bien. Ahora, cuando vemos la declaración flotante o la declaración de entrada, vemos cosas como el paréntesis de entrada bla, bla, bla, el paréntesis es igual a x, ¿verdad? Así que vamos a asignar algo. La pregunta es: ¿cuál es el valor residual que regresa? Y dentro de la función, nosotros, como escritores de la función, podemos determinar cuál es ese valor residual mediante la sentencia return. Así que, básicamente, aunque esta es realmente una función trivial, no tiene parámetros, la sentencia return hace dos cosas. Primero, detiene la función y salta a la siguiente línea, ¿verdad? Pero segundo, también determina el valor residual. Al decir devolver, si venimos aquí, hacemos esto y estamos en mitad de esta declaración impresa. Así que hace una pausa aquí y, luego, ejecuta este código y luego la respuesta dice: Oh, esta pequeña parte que era la función, devuélvela allí mismo. Eso significa que esto es realmente Hello Glenn impreso, que imprime Hello Glenn. Y luego pasa a la siguiente línea, vuelve a poner «saludo». Vuelve a ejecutar greet, entra aquí y ahora Hello se convierte en este valor residual. Ahora bien, no es muy inteligente, pero entiendes la idea. Este valor residual es como Hello Sally, así que imprime Hello Sally. He aquí un ejemplo un poco mejor de esto en el que utilizamos tanto argumentos como un valor devuelto. Así que, de nuevo, esto solo lo recuerda. Vamos a decir «saluda» y «en», así que «en» es «lang». greet va a ejecutar [NOISE] y ejecuta esto. Ahora hemos devuelto Hello, así que este Hello se convierte en esto. Así que Hello es el valor residual de la evaluación de la función, y así sale Hello Glenn. Así que ahora, hacemos esto, saludos. Así que llamaremos a este código, y es aparecerá como lang. Y en este caso, ejecutará esto y devolverá Hola. Así que Hola se convertirá entonces en esto reemplaza, y dice Hola Sally. Así que ahora vamos a hacerlo de nuevo, saludar a fr, saluda aquí, decimos fr como idioma, falso, verdadero, y luego regresamos. La devolución no viene aquí, la devolución está hecha. Eso es todo, ya has terminado, y también has especificado el valor residual de este pedacito, y eso es Bonjour Michael. Por cierto, Glenn, Sally y Michael son personas reales. Siempre uso nombres de personas reales que son personas reales que conozco. Bien, ahora lo que vamos a hacer es volver a echar un vistazo a la función máxima, pero vamos a entender cómo funciona el retorno. En realidad, se trata más bien de la devolución. Así que si echamos un vistazo al máximo, vamos a evaluar el lado derecho de esto para tener algo que sacar a lo grande. Así que Max, Hello World, dice que tomemos este parámetro y lo enviemos al máximo. Esta es la función máxima, ¿verdad? Así que Hello world entra al máximo como parámetro. No sabemos cómo se llama dentro de max, realmente no nos importa. Pero va a hacer algo, ya sabes, leer algunas cosas, comprobar si es una cadena o algo así. Y luego repasará un montón de cosas y descubrirá qué es lo más grande. Y averigüe esto, lea detenidamente y elija la w como la más grande. Y luego va a ejecutar una sentencia de devolución porque tiene que devolvernos la w. ¿Verdad? Así que, para comunicarse fuera de la función con el mundo real, aquí está nuestro mundo real, dice devuelve «w». Probablemente sea una variable, pero entiendes la idea. Tiene que ejecutar una declaración de retorno, y ese es el final de la ejecución. No continúa, ni siquiera ejecuta una sola sentencia después de la devolución. Pero luego nos devuelve para reemplazar en esa declaración original, la w se convierte en el valor residual. Y luego la w es lo que se convierte en grande. Ahora, después de un tiempo, no necesitarás analizar toda esta sintaxis con tanto detalle. Solo quiero que sepas cada carácter y lo que significan. Y reduce la velocidad a cámara lenta porque después de un tiempo escribirás estas cosas y ni siquiera pensarás en ello. Pero tienes que poder reducir la velocidad a cámara lenta si es necesario. Bien, puedes tener más de un parámetro, como cabría esperar. Esto dice que quiero dos parámetros. Una vez más, el nombre de estas cosas de aquí dentro apenas importa. Solo ese es el primer parámetro, ese es el segundo parámetro. En una llamada, pasamos 3 y 5. Así de fácil, el número y el orden de los parámetros son los mismos en la invocación de la función que en la definición de la función. Y simplemente sumamos estos dos números, la convertimos en una variable local y luego la devolvemos. Así que 8 se convierte en lo que regresa y queda atrapado en x. Así que más de un parámetro, más de un argumento, no hay problema. Los nombres de los parámetros dentro de las funciones no son gran cosa. Por lo tanto, algunas funciones no devuelven valores. Las llamamos funciones no fructíferas, y si devuelven valores, las llamamos funciones fructíferas. En resumen, esta fue una introducción bastante rápida a las funciones. Como dije, no espero que construyas un montón de funciones, pero quiero que las entiendas. Y así, cuando llega el momento y piensas: oh, vaya, es hora de crear una función. Sabrás cómo crearlas y sabrás cómo usarlas.