Así que ahora lo que vamos a hacer es seguir trabajando en esto. Vamos a hacer algo al día, vamos a hacer algo antes y algo después. Y vamos a lograr cosas diferentes. Así que lo primero que vamos a lograr es contar algo, ¿verdad? Estoy contando la cantidad de cosas que vamos a revisar. Ahora, en este caso, es un poco tonto. Pero, simplemente, en general, se llaman contadores. Digamos que teníamos punto punto punto punto punto, punto, un montón de estas cosas. Y no lo hicimos exactamente, podemos ver esto y decir que hay seis, ese no es el punto. La cuestión es que si tenemos un bucle y estamos siguiendo un bucle queremos llevar un registro de cuántos hemos visto. Bueno, haz esto de contar, ¿de acuerdo? Así que la forma en que funciona es poner una variable en 0. Esta es la parte superior, normalmente se llamaría contar, pero voy a usar un valor no mnemotécnico malo llamado zork, para que no te acostumbres demasiado. Así que hasta ahora, ¿cuántos hemos visto? Bueno, hemos visto 0. Y luego vamos a ir, la cosa va a ser 9, 41, 12. Así que esa va a ser la variable de iteración. Cada vez que sigamos el bucle, añadiremos 1 a zork, incremento es otra palabra para esto, zork = zork + 1. Imprimimos lo que estamos viendo e imprimimos el valor actual de zork. Así que, la primera vez hasta las 9, y luego, eso es lo primero que vimos, 41, la segunda. Así que, y cada vez, esto aumenta en 1. En realidad, no importa cuáles sean estas cosas, pero luego, lo ejecutamos muchas veces. Y cuando terminamos, decimos, vale, el bucle está hecho, ¿verdad? Ahí está el final de la cuadra. Y cuando todo está dicho y hecho, hay 6 cosas. Una vez más, 6 es algo obvio. Podríamos mirarlo y saber que hay 6. Pero esta es una forma de llevar un registro de la cantidad de veces que se ejecuta un bucle. Lo pones en 0 en ese lugar, le agregas 1 y luego imprimes el final. Al principio, antes de empezar, establézcalo en 0, añada 1 cada vez y, a continuación, imprima el recuento al final. Así que eso es contar. Lo siguiente que vamos a hacer es sumar una serie de valores. Así que en este caso vamos a sumarlos. Ahora tiene mucho más sentido y vamos a tener otra variable, zork. Probablemente llamaría a esto total. Durante el bucle, será el total acumulado y al final del bucle será el total. Así que total = 0, antes de nosotros, ese es el total acumulado de lo que hemos visto. Así que ahora sale 9 y 0+ 9 es 9, así que el total acumulado es 9 y 9 fue lo que vimos. Luego entra 41, luego sumamos 9 más 41. El total es 50, leemos 41, volvemos a subir y entra 12. 50 más 12 son 62. Así que ese es nuestro total acumulado. La próxima vez tendremos 3. 62 más 3 son 65. Entonces, esta línea se imprime. Entonces tenemos 74. Entonces, 65 más 74 son 139. Así que ese es el total acumulado. Vamos a hacer la última, 15. 139 más 15 son 154. Lo imprimimos. Y ahora vuelve a subir, pero el bucle está hecho, así que salimos. Así que al final, cuando todo esté dicho y hecho, este total acumulado se convierte en el total, 154. Así que sabemos con certeza que cuando imprimes todo eso, no lo imprimirías. Pero al final, si haces esto. Así que la diferencia entre el conteo y el total es que, en lugar de sumar 1 aquí, se suma lo que se está acumulando y se está sumando el total. Así es como calculamos los totales. Y, por supuesto, podemos hacer esto con un promedio, ¿verdad? ` Así que ahora vamos a tener un contador que establecemos en 0, un total acumulado que establecemos en 0 en la suma variable. Vamos a imprimir 0, 0. Por lo tanto, el recuento y el total son 0. Lo recorremos. Cada vez que terminamos, sumamos 1. Por lo tanto, serán 1, 2, 3, 4, 5, 6 cada vez. Y tenemos la suma = suma + valor, así que 9, 50, 62, 65, 139, 154. Así que este es el total acumulado. Este es el recuento. En realidad, esa es la suma en este caso, la variable suma. Y luego, esto es lo que estamos leyendo. Y finalmente terminamos. porque solo había seis cosas. El bucle for elimina todo esto. Y luego tenemos, vale, ¿cuántos nos dieron? Tenemos 6. ¿Cuál fue el total? Eran 154. Y luego divida la suma por el conteo y debería ser 25,0. ¿Está bien? Así que dividimos la suma por el recuento y ahora hemos calculado el promedio, en realidad debería ser 154 dividido por 6. Creo que debería ser 25.6666 o algo así. ¿Está bien? Así que entiendes la idea, sumas y puedes hacer más de una de estas cosas en un bucle determinado. Ahora, filtrar es la idea de que estamos buscando algo que cumpla con algunos criterios. Así que vamos a analizar todas las cosas del bucle. Estamos intentando averiguar si algo es mayor que 20 y vamos a declarar ese número grande. Así es como se pone un «si» en el bucle. Así que a veces este bucle no hace nada, a veces este bucle imprime un número grande. Por lo tanto, el valor va a ser 9 y eso es falso, por lo que no sirve de nada. El valor es 41, eso es cierto, así que imprime esto. El valor es 12, así que no hace nada. El valor es 3, no hace nada. El valor es 74, así que lo imprime. El valor es 15, así que es falso. Hecho. Ahora el bucle de forma sabe: oh, hemos terminado, pasa a la siguiente línea. ¿Vale? Así que este es un tipo de patrón de filtrado en el que vamos a hacer una sentencia if y a ejecutar condicionalmente algún código basándonos en el valor que estamos viendo por ahora. Es como buscar números grandes en nuestra larga lista de números. A veces, en vez de imprimir algo en mitad del bucle, como ocurre en las funciones, no solemos imprimir en ellas. Solemos preferir usar valores devueltos, a veces solo queremos una variable que nos diga si se encontró algo o no. Así que vamos a usar una variable booleana. Así que el booleano es otro tipo de variable. Tienes variables enteras, variables de cadena, variables de coma flotante. La booleana es otro tipo de variable. La booleana es un tipo de variable que tiene el valor Verdadero o Falso, eso es todo, solo puede tener dos. Por lo tanto, False es una constante en Python. Así que voy a decir encontrado. found es una variable mnemotécnica. Utilizo la palabra encontrado para esto todo el tiempo, pero no me quede atrapado en ella. Resulta que es una variable con el valor False. Así que lo imprimimos antes, es falso. Y ahora vamos a volver a analizar cada uno de estos valores. Y estamos buscando 3. Y queremos saber si encontramos 3 o no. Así que tenemos 9. Y sigue siendo falsa. Tenemos 41, sigue siendo falso. Tenemos 12, sigue siendo falso. Ahora tenemos 3, esto de repente se convierte en Verdadero y cambiamos la variable encontrada, que es la misma que se encuentra aquí, por Verdadera. Así que esta vez, cuando salgamos con 3, ejecutamos este código, luego lo imprimimos y es Verdadero. Ahora, con 74, esto es False, pero hemos cambiado la variable por found, para que no vuelva a cambiar a False. Así que ejecutamos el resto del ciclo. Y cuando terminemos, True. Y así, en algún nivel, si no imprimieras todo esto. Antes, después, eso significa que encontramos un 3. Podría haber pasado un millón de veces con esto y todo lo que sabemos cuando terminamos es que había un 3. Así que eso es lo que dice. Found comienza con False, hace bucles y bucles y bucles. Y si alguna vez lo encuentra, lo encontrado se convierte en Verdadero y luego podemos detectarlo mediante el bucle, sí, lo encontramos. Sí, eso pasó. No importa cuántos números miremos, uno de ellos en un momento dado, al menos uno de ellos era un 3. Ahora bien, si fuésemos un poco tramposos nos daríamos cuenta de que podemos poner un descanso aquí mismo. Justo ahí, porque una vez que sea verdad no volverá a ser falsa, así que podríamos detenernos. Así que hemos hecho un montón de cosas diferentes, ¿verdad? Hemos encontrado el más grande y hemos buscado un valor. Hicimos algunas sumas, hicimos algunos promedios y ahora, vamos a hacer el valor más pequeño. Así que, justo antes de hacer el valor más pequeño, repasemos lo que hicimos para el valor más grande. Bien, tenemos esta variable llamada largest_so_far que configuramos en -1, y luego la imprimimos y empieza a ser -1. Y luego pasaremos por este bucle, 9. Y el más grande hasta ahora es el 9 y luego el 41. Esa nos gusta más. Luego llegamos a los 12. No queremos eso. Fuimos 3, no queremos eso. Nos quedamos con 74 y 15 no hay ninguna diferencia. Luego sale y obtenemos 74. Ese es el más grande, no el más grande hasta ahora, pero el más grande que obtendrías. Así que la pregunta es, ¿qué harías para cambiarlo y hacer que busque el valor más pequeño de la lista? Ahora puedes ver que los humanos son buenos en esto. Pues oye, ¿cuál es el valor más pequeño? Son 3, sí, por supuesto, ya lo sabes. No, tenemos que pensar como un ordenador. ¿Cómo vamos a encontrar el valor más pequeño de la lista? ¿Qué cambiaríamos aquí? ¿Cuáles son algunas de las cosas que podrías cambiar? Hay al menos un par de cosas que cambiarías, ¿verdad? Así que lo primero que harías es cambiar esto de un signo mayor que a un signo menor que. Y cambiemos la palabra grande por pequeña. ¿Eso lo va a arreglar? Tómate un segundo, si cambiara toda la palabra más grande por la más pequeña, y cambiara la mayor que por una menor que, ¿se solucionaría el problema? Si lo hice, ¿qué número va a salir? ¿Va a ser el 3? ¿Va a salir eso? ¿Y si yo hiciera esto? ¿Eso lo va a mejorar? ¿Va a imprimir 3? Obviamente, si te miro fijamente, probablemente no lo haga. Era una pregunta capciosa, ¿verdad? Era una pregunta capciosa. Esto es lo que pasa cuando lo ejecutas. Así que empiezas, smallest_so_far es -1. Entramos con 9. ¿9 es menos que -1? No, no lo es, así que saltamos. Así que, el más pequeño que hemos visto hasta ahora es -1, y volvemos a subir. ¿41 es menor que -1? No, no lo es, así que nos saltamos. Así que el más pequeño hasta ahora es -1. ¿12? ¡No!. 3 no es menor que -1, 74 no es menor que -1. 15 no es menor que -1. Así que salimos y el más pequeño que hemos visto hasta ahora es -1. No, no lo es. Entonces, ¿cuál es el defecto de nuestra lógica? En primer lugar, la palabra más pequeña hasta ahora no significa nada. Podría ser gorp, zap o x. Así que cambiar la variable para que diga la más pequeña hasta ahora es muy engañoso, ¿de acuerdo? Llegados a este punto, apunta directamente a la pantalla hacia el único lugar que contiene la falacia, el error de este código. Si señalaste aquí, estás en lo correcto, ¿verdad? Cuando hacíamos el test más grande hasta el momento, teníamos en cuenta que estos números eran positivos. Y más pequeño_so_far, si empezamos en -1. Si son números positivos, pues smallest_so_far ya es más pequeño que los números más pequeños posibles. Entonces, ¿qué número podríamos poner ahí para que esto funcione mejor? Bueno, algunos de ustedes podrían sugerir que simplemente digamos que no pasa nada. Haré que sean 100. Va a funcionar bien, ¿verdad? 9 marcará, 41 lo ignorará, 12 no funcionará, 3 marcará. Y funcionará, funcionará, está bien. Funcionaría si llegases a los 100. Pero entonces, ¿qué pasaría si hubiera números de tres dígitos aquí? ¿Cómo funcionaría? Bueno, hagamos que sean 1000. Sí, ya está. No, no, no, hagamos un millón, o algo más, ¿verdad? ¿Qué número es lo suficientemente grande? De hecho, el código más grande que hemos hecho hasta ahora, si hubiera números negativos y todos fueran negativos, esto no va a funcionar muy bien. Espera, más grande hasta ahora, sí. Esto simplemente no va a funcionar muy bien. Porque, ¿y si todos son números negativos? Asumimos que eran números positivos, y funcionó bien, ¿no? Vaya, vaya, vaya, vaya, vaya, vale. Así que hay una especie de defecto. Estábamos usando este -1, hay una palabra para describirlo. Es como el valor de un indicador, no es realmente el número más pequeño que hemos visto. Es como un indicador de que no hemos visto ningún número. Y la verdad es que no podemos elegir un número para esto. Francamente, ya sea en el más grande o en el más pequeño, simplemente no va a funcionar. Entonces, ¿qué vamos a hacer? Vale, entonces, esto es lo que hacemos. Tenemos otro tipo de variable, recuerda que yo tenía una booleana, verdadera y falsa, entera, punto flotante. Hay una variable llamada None type, None. Solo tiene una constante. Así que los valores booleanos tienen valores verdaderos y falsos, los enteros tienen varios, los valores flotantes tienen muchos y los tipos Ninguno tienen una sola cosa: Ninguno. Lo vemos como la ausencia de un valor. La falta de un valor, ¿vale? Entonces, lo que vamos a hacer en su lugar es en nuestra variable más pequeña, eso es lo que vamos a hacer. Vamos a decir, ¿sabes qué?, antes de que comience este ciclo, el número más pequeño que hemos visto no es nada. No hemos visto ningún número en absoluto. Y ese será nuestro marcador para indicar que no hemos visto ningún número. ¿Vale? Es algo así como el código encontrado en el que establecemos que found es False y , más tarde, establecemos que found es verdadero. Pero vamos a usar el más pequeño igual a Ninguno. Ninguna es una variable, un valor, que podamos detectar claramente a diferencia de los números. Entonces, ¿podemos decir que el contenido del más pequeño es Ninguno? Si el más pequeño es Ninguno, es como si fuera más poderoso que el doble signo igual. Significa que es exactamente lo mismo que. Por lo tanto, si lo que preguntamos es el Ninguno más pequeño, eso solo es cierto si tenemos un Ninguno ahí. Si ponemos 17, el más pequeño no es Ninguno. Así es como funciona. Empezar con lo más pequeño es igual a Ninguno. Y luego, en el código tenemos un poco más de inteligencia. Si el más pequeño es Ninguno, significa que es la primera vez. Si el más pequeño es Ninguno, el más pequeño es el valor. Así que el 9 va a entrar aquí. Así que, si el más pequeño que hemos visto hasta ahora está vacío y no hemos visto nada, entonces consideraremos al primero como el más pequeño. Así que nuestro 9 se convierte en el más pequeño. Así es como imprimimos el número más pequeño hasta ahora es 9 y acabamos de ver el 9. Luego subimos. La segunda vez que sigamos este ciclo, esto siempre será falso de ahora en adelante, porque el más pequeño es un número y el número no es Ninguno. Bien, tenemos este valor de marca que es Ninguno solo por primera vez en el bucle. Así que eso es falso, así que se va a ejecutar aquí, el valor elif es menor que el más pequeño, que es 41. ¿41 es menor que 9 en este caso? Y la respuesta es no, no lo es. Así que queda 9, luego 12, 3 funciona. Así que el número 3 hace que este código se ejecute, así que lo cogemos. Así que es 3 y pasamos por 74 y 15. Se ejecuta dos veces más. Y luego, cuando terminemos, tendremos 3. Estamos comprobando el valor de un indicador y, a lo largo del ciclo, solo será más pequeño. El valor más pequeño solo será Ninguno la primera vez que se pase por el bucle, pero después ignoraremos esta pequeña parte. Esta es otra forma de pensar en esto, es lo que nos está preparando. Esto es empezar. ¿Está bien? Y esta técnica es una buena forma de hacer lo más grande y lo más pequeño. Usar esta opción es None y disponer de un poco de código que se active por primera vez en el bucle para obtener una especie de configuración de variables transmitidas en bucle. Bien, entonces el operador es y no es, ambos son operadores. Es y no es es como menor o menor o igual o no igual a. No dañan sus operandos y te devuelven un valor verdadero o uno falso. ¿Está bien? So is, None, and is not también es un operador lógico. Y hay otras veces que lo usamos. No deberías usarlos cuando deberías usar dobles iguales, por lo general los usas para un Verdadero, un Falso o Ninguno. Que no abusemos es, porque es, una igualdad muy, muy fuerte. Por lo tanto, es una igualdad más fuerte que el doble igual a, por lo que el doble es igual a es matemáticamente igual a con una conversión potencial. Pero es algo más fuerte, y no es lo contrario de lo que es. Bien, en este capítulo hemos hablado de algunos bucles definidos, algunos bucles indefinidos. interrumpe para salir de los bucles, continúa apareciendo de nuevo. continue funciona tanto en bucles como en bucles continuos. Las variables de iteración son la forma en que con los bucles while los construyes tú mismo y, en el caso de los bucles, for los construye por ti. Y cosas como el más grande, el más pequeño, el conteo , el promedio, etc., etc. Así que analizamos algunos modismos en los que se hace algo al principio, se hace algo en el medio y luego se obtiene la recompensa al final.