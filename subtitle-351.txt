Hola y bienvenidos al capítulo 3. Ahora vamos a hablar de la ejecución condicional. La ejecución condicional es donde empezamos a añadir más inteligencia. Ejecución secuencial, solo tienes que escribirlos y Python lo hace. Pero en la ejecución secuencial puedes elegir uno de los dos caminos: girar a la izquierda, girar a la derecha o ir en línea recta. Puedes tomar decisiones. Y esta es una parte esencial para hacer que las computadoras parezcan inteligentes. Por lo tanto, la clave de esto es la declaración «si». Por lo tanto, la sentencia if es la palabra reservada que indica que vamos a hacer algo de forma condicional. Y no es tan difícil de leer. Por lo tanto, la sentencia if tiene una condición. En realidad, es una pregunta, a diferencia de x = 5, que cambia potencialmente el valor de x. X menor que 10 es hacer una pregunta. Se pregunta, ¿x es menor que 10? Y eso devuelve un verdadero o un falso. Y este punto, dado que x es 5, x es de hecho menor que 10, por lo que es cierto. Estas sentencias if terminan en dos puntos y comienzan un bloque de texto con sangría. Es como un esquema que básicamente dice: si esto es cierto, haz esta afirmación. De lo contrario, omita la declaración. Entonces, en este caso, viene cuando x es menor que 10. Así que hace la afirmación, luego vuelve y dice que si x es mayor que 20, esta se evalúa como falsa y, por lo tanto, la omite. Por eso vemos impresiones y terminaciones más pequeñas. Y esta línea nunca se ejecuta. Por eso lo llamo condicional. Dependiendo de la pregunta que se haga, la línea dentro del bloque indentado se ejecutará o no. Así que puedes ver esto como si estuvieras conduciendo un coche, ¿verdad? Ejecutas esta sentencia, luego pasa a la siguiente, y luego hace la pregunta: ¿x es menor que 10? Si la respuesta es sí, gira en esta dirección y conduce hasta aquí y ejecuta este código, hace eso, y luego vuelve a unirse, y luego dice: ¿x es menor que 20? Bueno, dado que x es 5, la respuesta es no, y eso lo omite por completo. Y luego ejecuta esto y ya está hecho. Así que este código nunca se ejecuta, ¿vale? Así que cuando decimos condicional, decimos que sí, ese corrió, pero ese no funcionó. Por eso lo llamamos condicional, porque puede ejecutarse o no. La otra cosa importante de esto es la noción de sangría de que empezamos con un si tenemos estos dos puntos y luego hacemos una sangría. La indentación puede ser una variable. Tendemos a hacer una sangría de 4 espacios. Es el patrón recomendado. Y lo veremos dentro de un rato. Las indentaciones pueden tener más de una línea. Esta es solo una sangría de una línea en la que tienes una línea condicional. Pero veremos en un segundo cómo podemos hacer esto con más de una línea. Es un buen momento para volver a hablar de los operadores de comparación. El problema aquí tiene que ver con las limitaciones de los teclados de las computadoras en las décadas de 1950 y 1960, cuando la mayoría de estos lenguajes estaban diseñados. Por lo tanto, menos que en los teclados, menos que seguido de un signo igual es menor o igual al doble igual. Esta es probablemente la parte más difícil. El doble igual es un signo de interrogación. Recuerda que «igual» es una declaración de asignación. Tiene una especie de dirección. X = 1, ¿verdad? X = 1. Eso pone 1 en x. Si dices x = 1, te estás haciendo la pregunta: ¿x es igual a 1? Y no hace daño a x. Así que probablemente lleve un tiempo. Si estuviera diseñando un lenguaje, diría que asigne x a 1, y entonces sería un solo igual. Pero lo siento, no diseñé Python, así que no es así. Así que el doble igual es la versión con signo de interrogación de la igualdad. Mayor o igual que y mayor que y, por lo tanto, no igual es un signo de exclamación. Otra palabra para exclamación era bang. Decimos bang, igual o no igual. Por lo tanto, el signo de exclamación es como un énfasis no igual o similar. No sé, así es como lo recuerdo. Recuerde que nada de esto perjudica los datos que están consultando. Evalúan y luego nos devuelven un verdadero o un falso. He aquí un ejemplo de todas estas cosas en acción: para x = 5, todas van a ser ciertas. Si x es igual a 5, recuerda que ese es el signo de interrogación. Si x es mayor que 4 y la respuesta es sí, escribe mayor que 4. Si x es mayor o igual a 5, eso también es cierto. Así que esta parte funciona. También puedes, si solo es una línea de cosas, puedes llevar esta línea hasta el final aquí. Si x es menor que 6, imprima menos que 6. Si x es menor o igual a 5, imprima menor o igual a 5. Si x no es igual a 6, imprima 6. Y así ven este patrón de sangría, final de sangría. Sangría, fin de sangría. Sangría, fin de sangría. Sangría, fin de sangría. Así que esta es una parte importante de Python. No hay muchos lenguajes que hagan de la indentación de líneas algo sintácticamente significativo, pero así es como funciona Python. Por lo tanto, si no lo sangra, no va a funcionar de la manera que cabría esperar. Especialmente si vienes de un lenguaje de programación como JavaScript, Java o C, donde el espaciado real no importa. En Python, el espaciado sí importa. Por lo tanto, este es un ejemplo de un bloque de texto más largo con una sangría. Y ahora pueden ver más o menos cómo funciona esta sangría. X es 5, imprimimos antes de 5. Si x = 5, esto va a ser cierto porque lo es, dos puntos comienzan un bloque indentado. Ahora, al mantener la misma sangría, haces que todo esto forme parte del bloque ejecutado condicionalmente. Así que son tres líneas de código que ejecuta, ejecuta esta línea, luego ejecuta secuencialmente esta línea, ejecuta secuencialmente esta línea, e indicamos cuándo es que queremos salir de este bloque y luego continuar eliminando la sangría, ¿de acuerdo? Entonces, cuando es cierto, los ejecuta todos, ahora se ejecuta de forma secuencial, secuencial, secuencial. Y ahora dice que si x = 6, bueno, este va a ser falso. Entonces eso omite todo esto. Ninguna de estas carreras omite todos los bloques indentados. Por lo tanto, esta sangría es una forma de, en efecto, crear bloques más grandes de código condicional o bloques de código condicional de varias líneas. Por lo tanto, la indentación es importante en Python. Es más importante en Python que, literalmente, en casi cualquier otro lenguaje de programación. Siempre utilizamos la indentación en otros lenguajes de programación para hacer un seguimiento mental de los bloques de texto, pero no es ahí donde el lenguaje de programación se quejará si te equivocas. Así que tienes que pensar, ¿por qué aumentaste la sangría? Es como si después de una declaración de si o durante un tiempo, que veremos en un momento, mantienes la sangría, lo que significa que te quedas igual, o luego eliminas la sangría o la reduces. Y esa es la manera de acabar con un bloqueo. Así que lo reduces. Las líneas en blanco no importan y, por lo tanto , los comentarios por sí solos en una línea no hacen ninguna diferencia a la hora de hacer una sangría. Y mientras haces esta hendidura, es muy natural pulsar la tecla de tabulación del ordenador y entrar. Así que lo hiciste, bla, bla. Y luego, en la siguiente línea, presionas la pestaña. El problema es que Python puede resultar muy confuso si a veces usas cuatro espacios y, a veces, usas la pestaña, y el peligro es que se vea directamente en la pantalla, pero Python aun así se quejará contigo. Por lo tanto, si utilizas un editor de texto que podría estar poniendo pestañas en tu documento, encontrarás dónde las desactiva. Así que un editor de programas, y no estamos hablando ahora de un procesador de textos, estamos hablando de un editor de programas como el bloc de notas o un gestor de textos. Estos tienen la opción de convertir o no las pestañas en espacios. Por lo tanto, coloca una pestaña en el archivo o coloca espacios. Por lo tanto, este es un buen momento si utilizas uno de estos editores de texto para asegurarte de desactivar las pestañas o hacer que se expandan. Así no acabas en unas semanas o unos días con errores de Python que simplemente no entiendes y que te ponen de mal humor. Así que tienes que pensar en la hendidura y la abolladura. ¿Cuándo entras y cuándo vuelves a salir? Así es como definimos los bloques. Así que tenemos un código secuencial que mantiene la misma sangría. Ahora, vemos el si y vemos los dos puntos, eso significa que iniciamos una sangría. Y luego, para permanecer dentro de ese bloque de código, se mantiene la sangría y, para terminar ese bloque de código, se desindenta. Así que piensas que esto es como si estuviera desindentando. Hago esto a propósito, no es al azar. Si esto estuviera dentro, entonces funcionaría de manera diferente. El hecho de que esta impresión esté agotada significa que no forma parte de este bloque if. Estas dos sentencias forman parte del código condicional. La letra es lo que pasa después del «si», ¿verdad? Así que esto va a funcionar sin importar lo que estos dos puedan o no ejecutar en este caso, porque es cierto, van a correr y volver a salir. Así que este es un código condicional. Este es un código secuencial. Y si seguimos bajando, todavía no hemos hablado de bucles, pero la palabra clave for es un bucle. Y esto le dice que ejecute esta cosa 5 veces y termina en dos puntos. Y luego entras y tienes un código secuencial. Entonces tienes un si. Esto se denomina anidado. Es una manzana dentro de una manzana. Así que el if tiene otros dos puntos. Así que vamos aún más lejos, y luego bajamos a este nivel de este si, y más tarde bajamos al nivel del 4. Así que tienes que hacer coincidir estas cosas y decidir cómo vas a terminar tu código condicional, o en el código en bucle, lo cual veremos en la siguiente sección sobre cómo funciona. Entonces, lo que quieres hacer después de un tiempo, y no te llevará demasiado tiempo, es entrenarte para empezar a pensar en el hecho de que se trata de bloques de código, que puedes dibujar estos cuadrados alrededor de los bloques de código. Y he dibujado el cuadrado aquí, el «si» lo empieza. También puedes usar el colon como tu pequeño mecanismo. Y luego el indentador lo detiene. Así que este es el código condicional. Y luego puedes ver dónde empieza la f. Y luego es la línea que se alinea de nuevo con el 4. Ese es el alcance de todo el bucle for. Lo mismo ocurre con el if. Lo que se alinea, ese es el alcance de ese bloqueo. Por lo tanto, mentalmente, debe darse cuenta de que esta eliminación de sangría y sangría añade significado a su programa. Quiero decir, definen absolutamente qué cosas se van a ejecutar como parte de una sentencia if o independientemente del valor de la sentencia if. Así que empieza a verlos. Y en términos de anidación, puedes verlos uno dentro del otro. Es como las muñecas rusas, en las que tienes un bloque de código dentro. Tienes otro bloque de código, y créeme, vamos a bajar, bajar, salir, salir, salir. Así que empieza a ver estas hendiduras como bloques. Empieza a sentirlo. Como dije, decisiones anidadas. Había un bucle a favor con un si. También podemos tomar una decisión en la que haya un si dentro de un si. Por lo tanto, en este caso, x = 42. Si x es mayor que 1, es cierto. Entonces vamos a imprimir esto. Si x es menor que 100, eso es, de nuevo, cierto. Así que vamos a entrar y ejecutar esto. Y luego hemos sido sangrados dos veces. Así que esto se alinea con el si. Así que esto funciona como el final de este bloque y como el final de este bloque porque se alinea aquí. Así que si lo miramos desde la perspectiva del GPS, es cierto. X es mayor que 1. Lo imprimimos y hacemos otra pregunta. Esa es una pregunta. Y pulsa «Sí». Y ahora continuamos bajando. Así que salimos del bloque de sangría y, a medida que te dibujas, ves que esto tiene una sangría una vez. Y este está marcado dos veces, tal y como lo dibujé. Y lo mismo ocurre aquí. Esto se indenta una vez, una vez y luego dos. Estoy muy ocupado ahí. Este está marcado una vez. Este está marcado una vez. Este está marcado dos veces, ¿verdad? Así que empieza a contar esas guiones y conoce cómo funcionan las guiones. Así que tenemos decisiones unidireccionales y, muy comúnmente, tenemos una decisión bidireccional. A esto lo llamamos de otra manera. Básicamente queremos hacer una cosa u otra, es como una encrucijada. Si algo es cierto en este caso tiene una calificación de x superior a 2. Bueno, son 4, así que es cierto que hacemos una cosa y si es falsa, hacemos otra. En este ejemplo en particular, no hacemos este, solo lo hacemos aquí. Pero tienes la idea de que con una prueba de si, elegimos alternativamente entre una y otra de las opciones. Así es como escribimos eso en Python. Decimos código secuencial, signo de interrogación, dos puntos y luego tenemos la parte verdadera. Esta es la parte que se ejecuta si la pregunta se evalúa como verdadera. Y luego eliminamos el indentamiento y utilizamos la palabra clave else. De lo contrario, es una palabra clave de Python y aquí ves otros dos puntos. Así que, en cierto modo, desindentamos, decimos otra cosa y luego volvemos a indentar, y luego tenemos esta parte y así es como capturamos la otra mitad. Y luego, por supuesto, funciona pase lo que pase. Así que si tuviéramos que hacer esto, si es cierto, ejecuta esto y luego se salta aquello. Y si fuera falso, que no lo es, se saltaría esto, lo ejecutaría y, a continuación, continuaría. El punto es que si usas una estructura if else, una de estas dos cosas se ejecutará, y es más o menos lo mismo que esto. Viene aquí. No hay ningún escenario en el que ambos funcionen, vaya a ejecutar uno y, al ejecutar uno, no ejecutará el otro. Así es como ocurre un si no. A continuación, hablaremos sobre algunos patrones de ejecución más condicional, cosas un poco más complejas, de lo contrario, etc.