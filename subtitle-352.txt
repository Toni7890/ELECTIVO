Así que bienvenidos, ahora vamos a desarrollar y hablar sobre algunos patrones de ejecución condicional un poco más complejos que puedes crear. Así que, al hacer lo de «si, entonces», una de las cosas que hay que hacer es visualizar los bloques y empezar a pensar en ellos. Y en este caso, pensarías que el bloque comienza por el «si» y termina después de la última línea indentada. Pero el «si» y «lo otro» son parte de una cosa y puedes pensar en esto como el bloque, ¿verdad? Y una de las cosas de estos bloques es que tienen una entrada y una salida, no es que sea un gran problema. Pero es una buena manera de pensar en cómo empiezas mentalmente a dibujar los bloques. Ves una entrada y una salida, y hay cierta complejidad, hay cierta lógica de que estás construyendo una especie de edificio. Y así es como funcionan estos bloques. Por lo tanto, el siguiente paso en cuanto a complejidad es un «si» de múltiples vías. Y eso usa una palabra clave llamada elif, que en realidad es una combinación de else y if. Así que la forma en que funciona es, probablemente, más fácil hacerlo en una versión GPS. Si viene aquí, olvida lo que hay aquí, pregunta sí o no. Si es así, ejecuta este y ya está todo listo. Si es no y luego sí, ejecuta este y ya está todo listo. Y si no, no, no, ejecuta este y ya está. Una cosa clave es que solo va a hacer una de estas tres. No va a hacer dos, solo va a hacer una. Y revisa estas preguntas en orden. Y luego esta otra cosa es como un comodín. Así que echemos un vistazo a cómo funciona este en particular. Depende del valor de x. Entonces, ¿qué pasaría si x fuera 0? Bueno, si x fuera 0, entraría y se preguntaría: ¿x es menor que 2? Sí, lo es. Así que ejecutaría este código y terminaría aquí abajo. Así que venía aquí, es cierto, corría, y ahora saltaba hasta el final. Si dibujas bloques, la caja sería esta caja de aquí. Sale de la caja, o si dibujas la caja aquí, la caja estará justo aquí. Una vez que hayas terminado con esta línea de código, con este bloque de texto ahí mismo, o bloque de código, sales del bloque. No te gusta volver y mirar esta pregunta. Has huido, una cosa se ha hecho realidad y ya está. Si, por otro lado, x fuera 5, verías una situación en la que aparecería. Esto sería falso, por lo que se saltaría. Luego pasa a la siguiente elif, y esto se hace realidad. Entonces entra y hace este código, se agota y está listo. No ejecuta eso, no ejecuta eso, ejecuta eso. Así que entra. No, no son menos de 2. Es inferior a 10, así que ejecutaremos ese pequeño bloque de código, y ya hemos terminado por completo. Así que no, no, pero sí, ¿vale? Así es como funciona. Estas se hacen en secuencia. No se ven en paralelo o todos al mismo tiempo. Si, por otro lado, x fuera 20, diría falso, omita, signo de interrogación. Falso, salta. Oh, si no. Entonces el otro siempre se activa si llega tan lejos, y luego lo ejecuta. Así que aquí decimos que si es menor que 2, no lo es, es menor que 10, no lo es. Y si está ahí, simplemente golpeamos la otra parte, terminamos y continuamos. Así que esta parte no funciona, esta parte no funciona y esa parte funciona. La regla es que una de las tres se ejecutará y las otras dos no. Solo se activa una vez. Una vez que se activa, se hace con toda la instrucción if. Y de nuevo, lo veo como el bloque, y lo verás en un segundo. Una vez que una de estas cosas se hace realidad, ejecuta esto y luego sale del bloque por completo. Así que hay otras variantes de esto. Puedes si quieres no tener más. Así que no hay necesidad de tener otro. Lo que hemos hecho es simplemente desindentar la siguiente línea. No hay más aquí, pero está bien. Significa que por algún valor de, es posible que tampoco se ejecuten, sí, porque no hay nada más. Si hay más, al menos uno se ejecutará. Pero si no hay nada más, entonces podría ser posible que se ejecutara cero. En este caso, x es 5, no va a hacer esto, sino que va a hacer aquello porque x es menor que 10. Pero si x fuera, por ejemplo, 50, entonces eso sería falso, eso sería falso, y simplemente vamos. Y entonces ninguna de estas dos cosas se ejecutaría si x fuera 50. ¿Vale? Así que solo significa que no tienes que tener otra si no quieres. Además, puedes tener muchos elifs. Si x es menor que 2, haz esto, elif, elif, elif, elif. Y recuerda, los comprueba en orden: primero, segundo, tercero, cuarto, quinto. Así que si x fuera 15, esto sería falso, esto sería falso, esto sería cierto, por lo que ejecutaría este código. Y luego caería lo que venga a continuación. Y, de nuevo, solo una de ellas se activará. No, no, sí, no, no. Quiero decir, 15 es de hecho menos que 40. Si llegara aquí, sería cierto, pero no importa, porque uno se activa y se queda con todo el bloque, y ahí está todo nuestro bloque. Así que tan pronto como ejecute uno, lo siguiente que hay que hacer es salir inmediatamente del bloque. Vale, ¿lo tienes? Vale, aquí hay un par de acertijos. Te daré un segundo para pausar esto. Y la cuestión es que, si observas algunas de ellas, dependiendo de un valor concreto de x, no harás que se ejecute ninguna de ellas. Entonces, ¿qué es lo que nunca ocurrirá con un valor concreto de x? Lo que significa que puedes elegir cualquier valor para x que desees, pero hay algunos que no puedes hacer que se ejecuten. ¿Vale? Así que haré una pausa de un segundo y dejaré que pauses el vídeo si quieres y luego volveré y te lo explicaré. Vale, tuviste algo de tiempo para hacer una pausa. Espero que hayas hecho una pausa o no, pero no importa. Puedes hacer una pausa mientras hablo hasta que empiece a dibujar y te diga la respuesta. Bien, en este caso, si x es menor que 2, haz esto; si no, si x es mayor o igual a 2. El que nunca se va a ejecutar es este de aquí. Y eso se debe a que, sin importar el valor de x, es menor que igual a 2 o mayor o igual a 2. Así que para cualquier valor de x, sin importar el que elijas, se calculará con este o con este. Pero nunca lo va a ejecutar para ningún valor de x, ¿de acuerdo? Así que eso es un poco complicado. Resulta que construí mis preguntas lógicas de tal manera que cubrían todos los valores de x, por lo que el resto era un poco irrelevante. Ahora, ni siquiera dibujaría esto de esta manera. Si tuviera que dibujar esto o escribir este código, probablemente haría que fuera otra cosa: y esto no estuviera ahí. Pero esto era más un rompecabezas que cualquier otra cosa. Así que en la próxima, debemos recordar que estas cosas suceden en orden. Así que si x es menor que 2, vamos a ejecutar esto. Si es menor que 20, vamos a ejecutar esto. Si es inferior a 10, vamos a ejecutar esto. Pero el problema es que todos los valores de x que son menores que 10, para los que esto sería cierto, siempre son ciertos. Así que un valor como 6, se convierte en realidad. Eso significa que si es algo así como 6, va a ejecutar esto y saldrá y nunca hará esta pregunta, ¿verdad? Así que esa es la clave, aunque esto es cierto y esto es cierto para el 6, ni siquiera llega aquí porque este se activó primero. Vale, y por eso esta es la línea de código que no importa cuál sea el valor de x, nunca se ejecutará. Vale, entonces el último código condicional es lo que se llama estructura de prueba y excepción. Y si aprendes otros lenguajes de programación, este tipo de detección de errores es un concepto más avanzado. Pero en Python solemos usarlo antes porque hay cosas en las que, si no lo usas, el código explota. Y la idea de intentarlo es que tienes un fragmento de código que sabes que puede fallar, así que quieres contratarlo con una póliza de seguro y decir: oye, pruébalo. Si funciona, genial, si no funciona, haz esta otra cosa. No explotes, no consigas que te rastreen. Así que esta es una forma de eliminar o detectar un rastreo. Algo que de otro modo sería un rastreo. Para eso sirve esto. Así que si tienes alguna línea de código y sabes que podría explotar y tener un rastreo, entonces usa try/except para evitarla, ¿de acuerdo? Así que echemos un vistazo a algo. Este es un ejemplo que teníamos del código anterior. Y al bajar, coloca Hello Bob y luego lo convierte en un número entero. Y sabemos que si estas cosas no son dígitos, el código explota y se ejecuta y obtenemos el rastreo. Y el rastreo se produce debido a esta línea que está justo aquí, pero la clave del rastreo es que el rastreo, como te dije antes, se detiene. Y se detuvo en la línea 2, lo que significa que esta es la última línea que ejecutó, pero no continúa, lo que significa que este código ha desaparecido. Quiero decir, nunca llega porque es como: estoy confundido, voy a dejar de fumar, lo he dejado en la línea 2, ¿de acuerdo? Dejé de fumar en la línea 2. Así que ese código, es como si no estuviera ahí. A veces te parece bien, solo quieres explotar y quieres ver el mensaje, quieres ir a ver la línea 2 y arreglar la línea 2 o tal vez has escrito cosas incorrectas. Pero a veces quieres controlar esto. Quieres decir, sabes qué, sé lo que quiero hacer aquí, y no quiero morir, no quiero estallar. Quiero continuar, en su lugar quiero publicar un mensaje de error. La clave está en que, cuando este código falla, es algo que te tomas como algo personal porque tú eres ese conjunto de instrucciones, y cuando se produce un rastreo dentro de la memoria o la CPU, eres tú el que está siendo vaporizado. Te han rastreado, así que nos lo tomamos como algo personal. Quiero decir, si utilizaras un software que he creado, como el grabador automático para esta clase, y empezaras a recibir rastreos, yo diría: oye, eso es algo personal. No hice bien mi trabajo, no detecté todos los errores. No he pensado en todo. Podrías escribir algo que haga que mi código explote. Así que me lo tomo como algo personal. Por lo tanto, tenemos que ser capaces de compensar las situaciones que sabemos que pueden provocar errores. Especialmente aquellas en las que el usuario puede escribir algo que puede hacer que mi programa explote. ¿Realmente voy a dejar que arruines mi programa? Voy a compensar. Te lo diré, lo siento, son datos incorrectos. Pero no quiero que veas nunca un rastreo porque es un poco vergonzoso ver el rastreo de un programador profesional. Vale, así es como funciona, son unas cosas con algunas hendiduras y dos puntos. Parece mucho, pero no te preocupes, ya lo descubrirás. La idea es que tengas una línea de código que sepas que es peligrosa. Así que esta conversión de un número entero, digamos que proviene de una sentencia de entrada. En este caso, haremos que sea Hello Bob. Sabemos que esto va a fallar. Por lo tanto, esta es la línea en la que, en cierto modo, queremos contratar un seguro. Así que en vez de poner esta línea aquí, como hicimos en el ejemplo anterior, la pusimos ahí mismo. En lugar de tomar esa línea, diríamos, ¿sabes qué?, vamos a tomar y poner esto en un bloque de try and except. Así que decimos la palabra intentar. El try termina en dos puntos, lo que significa que es un bloque de código indentado. Y luego pusimos la línea peligrosa ahí, y luego pusimos «excepto». Y luego la excepción es como otra cosa, un «si-then else», pero lo que realmente es es un código que Python ejecutará si algo sale mal. Así que esto se ejecutará y funcionará y se saltará esto. O si sale mal, va a correr, explotar, y luego hacer funcionar estas cosas y luego continuar. Pero en ningún caso obtendrá un rastreo, lo que significa que si esta línea va a generar un rastreo, en realidad solo ejecuta la cláusula de excepción. Así que si las cosas salen bien, haz esto, si las cosas no funcionan, haz esta otra cosa. Así que en este caso, cuando esto funcione, fallará, porque así es Hello Bob. Y luego saldrá aquí y lo pondrá en -1. Y eso va a estallar. Pon esto en -1, eso lo imprimirá. Así que dice: Primero es igual a -1. Así que no lo rastreamos. La vez anterior que lo analizamos, lo rastrearon porque lo detectamos. Ahora bien, la forma en que funciona try/except es que si todo está bien, no tiene ningún efecto. Así que si, lo siguiente que vamos a convertir es 123, los dígitos 1, 2, 3 de una cadena. Hacemos un intento e intentamos convertirlo y funciona, así que seguimos adelante. No dirigimos el excepto. Por lo tanto, este código no se ejecuta porque tuvo éxito, no se iba a generar ningún rastreo. Se ha generado un rastreo aquí arriba. Aquí no se generó ningún rastreo, por lo que aparece y el resultado es que istr termina con un número entero, 123. Así que es una póliza de seguro o dice: Sé que esto podría fracasar y, si lo hace, le daré un texto alternativo o un código alternativo para que lo ejecuten. Lo que pasa con el bloque de prueba y excepción es que puede que te sientas tentado a hacerlo, y es que, si te estás cansando de los rastreos y de los fracasos , tal vez quieras poner todo tu programa en un bloque de prueba y excepción. Y podrías decir que inténtalo, bla, bla, bla, y luego, excepto que pase algo malo. El problema es que si tu programa está fallando, realmente quieres saberlo. Y la forma en que funciona el bloque de prueba y excepción es que, si está en medio de un bloque de intento y excepción y algo sale mal, como en esta línea en particular, no regresa y termina el bloque de intento y excepción. De hecho, sale al final y luego sale. Y para dibujar esto en un diagrama, aquí vamos, empezamos con esto y estamos en el bloque de intentos. Estamos imprimiendo, imprimir es seguro, no hace daño a nada. Hacemos esto, y esto se estropea con un rastreo. Rastrea y luego dice ir al bloque de excepciones, ejecutar lo que esté en el bloque de excepciones y luego continuar. Lo que no va a pasar es que no vaya a volver a subir y hacer esto, o que no vuelva a intentarlo. No, no, no, no. Una vez que obtiene el bloque de excepciones, solo hay una salida al final, por lo que esta línea de código nunca se ejecuta. Y esa es una de las cosas que intentamos hacer en la que simplemente no ponemos demasiadas cosas. Pondrías esta declaración impresa aquí y esta declaración impresa aquí, y solo pondrías una línea en el bloque de prueba y excepción, de ser posible. A veces pones unas cuantas líneas más ahí, pero tratas de minimizar. Sabes qué línea es peligrosa. La impresión no es peligrosa, estas dos huellas no son realmente peligrosas, no las pongas en el bloque. Porque cualquier línea del bloque, tan pronto como choca con una línea defectuosa con un rastreo, sale del bloque, ejecuta el excepto y luego continúa. He aquí un ejemplo más práctico, en el que leeremos un número del usuario e imprimiremos «Buen trabajo» o «No es un número». Entonces, tomamos una sentencia de entrada, que se detiene y espera a que la escribamos, y luego escribimos 42. Y 42 entra en rawstr y entonces sabemos que este int es peligroso. ¿Verdad? Y este rawstr proviene del usuario, independientemente de lo que haya escrito el usuario. Así que lo ponemos en el bloque try, y si es 42, se convierte y dice que ival es mayor que 0, lo imprimimos, así que dice: Buen trabajo. Ahora, volveremos a ejecutar este código. Bien, lo ejecutamos por segunda vez y ahora ingresamos algo, dice cuarenta y dos, pero es como f-o-r-t-y. Así que cuarenta y dos es lo que entra aquí. Nosotros, como programadores, no teníamos control sobre lo que escribía nuestro loco usuario, ¿verdad? Empiezas a ser programador y los usuarios locos hacen locuras con tus programas de mala calidad, aunque solo tengan siete líneas. Así que tenemos cuarenta y dos en camino, sabemos que esto va a estallar, este int va a estallar con un rastreo. Pero no pasa nada, lo hemos compensado y le hemos dicho a Python: oye, sabemos que eso puede pasar y si detectas un rastreo, pasa directamente al bloque de excepciones, ejecuta esto, ponlo en -1 y continúa. Así que este es el desindentamiento del bloque try/except, y si es mayor que 0 decimos: Buen trabajo. Pero en este caso, no lo es, y decimos: No es un número, por lo que sale con No es un número. Lo que no está aquí es un rastreo. No hay ningún rastreo en esto, eso es lo que hemos conseguido. Y no duele. Cuando funciona, el comando try/except no hace nada porque el código except, cuando funciona, se ignora. Así que es como el código que agregas en caso de que algo suceda en otra línea de código. De hecho, es muy guay. Así que tienes un par de ejercicios y yo tengo algunos vídeos de esos ejercicios. En resumen, de lo que hablamos en este capítulo es de los operadores de comparación, de las preguntas lógicas. Una clave es que estos operadores de comparación no cambien sus argumentos. Puedes decir que si x es menor que 5, no cambia el valor de x. Tenemos la sangría y la importancia de la indentación. Decisiones unidireccionales con si, decisiones bidireccionales con if-then else. Decisiones anidadas en las que hay un «si» dentro de un «si» que se mueve hacia adentro. Si no, y luego intenta, excepto para detectar los errores que quieras detectar, ¿de acuerdo? Así que, muchas gracias.