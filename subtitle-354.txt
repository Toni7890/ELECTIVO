Así que bienvenidos de nuevo. Ahora, continuaremos con el lado derecho de los enunciados de las tareas y hablaremos un poco más sobre la complejidad de lo que se puede hacer con estas expresiones. Por lo tanto, todos los lenguajes de programación tienen varios operadores en los que se dice x+1 o x-1 o algo parecido. Históricamente, estos operadores provienen del tipo de caracteres que estaban en los teclados de las computadoras en la década de 1960, literalmente. Estas cosas llamadas teletipos provienen del final de la Segunda Guerra Mundial y tenían un determinado conjunto de caracteres. Partíamos de un conjunto de caracteres matemáticos, donde la multiplicación es una cruz grande o un punto en el centro y la exponenciación es elevar un número pequeñito por encima de él. Y simplemente no podíamos representarlos en esos teclados tan rudimentarios o terminales rudimentarios. Así que tuvimos que mapear las fórmulas y funciones matemáticas en función de lo que se podía hacer. Así que esos teclados de hace 40 o 50 años tenían un plus. Así que un plus es un plus, tenían un menos. Pero la multiplicación, que normalmente es cruzada, es una estrella. Y la división, en la que no puedes poner cosas una encima de la otra, así que simplemente hiciste una barra para dividir. Y al llegar al poder hay una estrella doble. Ahora bien, el operador restante es algo que no se suele utilizar en las calculadoras, pero es muy importante para los ordenadores y veremos esto. Por lo tanto, el operador de suma es bastante sencillo. Lo he estado usando sin siquiera hablar de eso, de la multiplicación y la división. Así que, esto es 5,280 dividido por 1,000, lo que me da 5,28. Pero la que probablemente sea más interesante es esta operación de módulo, o resto. Por lo tanto, la forma en que funciona la operación restante es, en particular si se trata de un número entero, si realiza la división. Así que es casi como una división, j dividida por 5, pero en vez de dar el cociente, este es el cociente, da el resto. Por lo tanto, 5 dividido por 23 es 4 y queda 3. El 3 es lo que recibes a cambio. Ahora puede que te preguntes, ¿por qué es útil? Así que una de las formas de hacer que esto sea útil es elegir un número aleatorio grande y luego usar el operador de módulo, el operador restante, con 52. Y luego terminas con un número entre 0 y 51, y entonces puedes elegir una carta. Así que puedes tomar un número aleatorio, pero modulas a 52 y ahora puedes tener un número aleatorio que sea de la carta. O si quieres tirar un dado, puedes hacer un número grande y aleatorio, cogerás el módulo 6 y luego te dirá qué lado del dado. Así que, como juegos y esas cosas. Hay otras situaciones en las que puedes hacer cálculos pares e impares. Por ejemplo, ¿es un número impar un número par? Divídalo por 2 y vea cuál es el resto. Así que, toda esta noción del operador de módulo es muy útil en algunas situaciones. Y por eso nos obsesionamos un poco con eso. El operador eléctrico, esto es como 4 veces 4 veces 4, que es 64. Así que esas son las expresiones numéricas. Ahora bien, estas también tienen un orden de evaluación, y la forma en que funciona es en matemáticas, hay un orden de evaluación. Hay algunos operadores que son más potentes que otros operadores. Y siempre puedes, si eres inteligente, poner paréntesis, y la mayoría de los programadores siempre ponen paréntesis. Así que si estuviera escribiendo esta línea de código y quisiera que fuera fácil de entender para ti para que pudieras leerla más fácilmente, simplemente te pondría los paréntesis. Así que yo diría que 5 elevado a la sexta potencia va primero. Entonces, este 4 dividido por el que viene es el siguiente. Luego, este 2 por 3 es el siguiente, y luego evaluamos el resto de estas cosas de izquierda a derecha. Así que acabo de añadir los paréntesis que son iguales. Esto es exactamente lo mismo que ocurriría sin los paréntesis, porque esto ocurre primero. Esta parte ocurre en segundo lugar, esta en tercer lugar, y luego todas estas otras cosas pasan en cuarto lugar. Así que hay un orden, pero te enseñaremos cuál es el orden si no vas a usar paréntesis. Así que la regla es que los paréntesis lo anulan todo. La exponenciación es la más poderosa, la multiplicación, la división y el resto son iguales. Son los siguientes más poderosos. Y suma y resta. Y luego, en caso de duda, ve de izquierda a derecha. Entonces, si hay un montón de adiciones, simplemente ve de izquierda a derecha. Si hay sumas y restas en un montón de cosas, vas de izquierda a derecha, ¿de acuerdo? Así que esta es una pregunta clásica de un examen sobre los deberes de informática en la que simplemente dirías: Vale, ¿con qué se evalúa esto? Por supuesto, si tienes Python, simplemente escríbelo y te dirá cuál es la respuesta. La forma en que solía hacerlo, cuando hacía estos deberes, era porque escribía la expresión en una hoja de papel. Y luego lo revisaba y averiguaría qué era lo primero y tendría mucho cuidado al respecto. Y yo digo: bueno, la exponenciación ocurre primero. Así que elevaré el 3 a la tercera potencia, que es 8. Y luego lo reescribiré todo, 1+ 8 dividido por 4 por 5. Y luego me olvidaba de esto, miraba aquí y decía: Vale, ¿qué es lo primero? Bueno, 8 dividido por 4 es lo primero. Bueno, entonces sería como 8 dividido por 4, bueno, eso nos da 2. En este caso, nos da 2.0. Y entonces tendría 1 + 2,0 veces 5. Y miro, y ese es el siguiente, así que acaba siendo 10.0, y acaba siendo 11.0. Y es por eso que se imprime la versión 11.0. Y así, si no hay paréntesis, puedes averiguarlo. Otro tipo de pregunta de examen es preguntar cuáles serían los paréntesis. Así que primero se hace la exponenciación, en segundo lugar se divide y luego se pone otro paréntesis, porque ese resultado se multiplica por 5. Otra forma de responder a la misma pregunta es poner los paréntesis donde pertenecen. Como dije, primero los paréntesis, la potencia en segundo lugar, la multiplicación en tercer lugar, la suma y luego de izquierda a derecha. Así que cuando no tienes nada más que sumar y restar, vas de izquierda a derecha. Cuando no tienes más que multiplicar y dividir, vas de izquierda a derecha. Empieza con el que está más a la izquierda. A veces no importa. Además de la suma y la resta, por lo general no importa, pero en la multiplicación y la división sí puede importar, de izquierda a derecha. Bien, hemos estado hablando de variables, hemos estado hablando de constantes y hemos estado hablando de expresiones. Pero también tenemos constantes que son números enteros, tenemos constantes que son números de coma flotante y tenemos constantes que son cadenas. Y podemos manipularlos. Y Python rastrea cuidadosamente no solo cuál es el valor de una variable, sino también qué tipo de valor es. Entonces, ¿es una cadena, es un número entero, es un punto que fluye? Y a veces esto marca la diferencia. Y aquí hay un pequeño código de ejemplo. Tenemos este operador plus. Y el operador más está viendo sus dos operandos, 1 y 4. Es como: oh, esos son números enteros. Sé qué hacer con los números enteros. Eso significa sumar. Entonces, suma 5 y luego lo coloca en ddd y sale 5. Por otro lado, podemos usar el mismo operador positivo concatenando cadenas porque el operador positivo mira a su izquierda, mira a su derecha y dice, vaya, esas son cadenas. Y sé lo que quieres decir. Creo que quieres concatenar esto. Y así terminamos con: hola, el espacio está construido con mucho cuidado porque el signo más no añade espacio. Así que esto termina siendo hola espacio, y ese pequeño espacio es el espacio de aquí. Así que Python sabe, en este ejemplo, que todas estas son constantes, pero sabe el tipo de constantes y conoce el tipo de variables. Y puede hacer cosas muy diferentes. Y puede estallar y ser infeliz, como veremos pronto, según el tipo de cosas. Así que aquí tenemos un ejemplo de algo que es infeliz. Así que he concatenado hola y ahí, y luego Python está encantado de hacerlo, y luego lo meto en eee. Y ahora digo que quiero agregarle 1, y mira a su izquierda, mira a su derecha, esto es una cadena y este es un número entero. Y Python dice: No sé cómo hacerlo. Python podría saber cómo hacerlo, pero ahora se elige para saber cómo hacerlo. Y así se obtiene el temido rastreo, y el rastreo es como un error de sintaxis. Python no te dice que eres un mal programador o que nunca vas a ser programador o que eres completamente inadecuado para un programador. Lo que Python está diciendo es que yo, Python, estoy perdido. Me dijiste que hiciera algo que no sé cómo hacer. Tienes que recordar qué es lo que soy capaz de hacer como Python. Por favor, vuelve y arréglalo. También significa que el programa se detiene. Lo que significa que si estás en un script de varias líneas y estás haciendo un montón de cosas y aquí hay un rastreo, el código que sigue a eso se cierra, ¿de acuerdo? Y eso se debe a que has llegado a la conclusión de que Python está perdido y Python se resiste a continuar. Ahora veremos en un momento que podrás obligarlo a continuar si quieres. Pero como dijiste algo que Python no entendió, simplemente se retira en ese momento. Y el rastreo, la línea 1 en este caso, te dice dónde explotó esta cosa. Y esto parece un galimatías asqueroso, pero después de un tiempo, no tardarás en relajarte y buscar la palabra rastreo. Eso significa que Python se fue de alguna parte. Te dice dónde. Y luego miras un poco más allá y te dice qué pasa. TypeError, no está satisfecho con el tipo y todavía hace referencia a esta línea de código. Dice que no puedo convertir objetos enteros en cadenas de forma implícita. Así que es como si le hubieras dicho que hiciera algo combinando una cadena y un número entero. Y Python dice: «Estoy perdido», pero te estoy dando todas las pistas sobre cómo me perdí, qué es lo que me perdió, dónde me perdí. Me perdí, dónde me perdí y qué es lo que hizo que me perdiera, y Python está haciendo todo lo posible para que sepas qué es lo que está mal. Así que no lo veas como algo malo. Mira esto como si fuera, oh. No me he comunicado con Python de la forma en que quiero comunicarme. Hay una manera de resolver esto, hay una manera de hacer algo aquí, pero. Así que si tomamos Python y pensamos en Python y decimos: oye, eres tan exigente y te vuelves loco si cometo el más mínimo error con los tipos. Ayúdame aquí. Y resulta que Python tiene una función incorporada llamada type. De nuevo, se escribe con paréntesis, las llamadas a funciones tienen paréntesis y pasamos algo. Y decimos: oye Python, dime cuál es el tipo de la variable ee y Python imprime: oh, es una cadena. ¿Cuál es el tipo de la constante «hola»? Es una cadena. ¿Cuál es el tipo de constante 1? Sería un número entero. Así que Python realiza un seguimiento del valor de las variables y constantes, el valor y el tipo de las mismas. Así que tenemos que manipular esto y ser conscientes de ello a medida que avanzamos. Así que hay varios tipos de números con los que ya hemos estado jugando implícitamente. Como dije, puedes dar una variable para escribir o puedes dar una constante para escribir. Las variables y constantes que no tienen decimales son números enteros, lo que se denomina números enteros. Y las variables que tienen decimales se denominan puntos flotantes. Incluso si fuera un 98,0, seguiría siendo un punto flotante. Tan pronto como pongas el punto ahí, significa que es un punto flotante. Están representados internamente de manera diferente. Los números de coma flotante tienen un rango mayor que los números enteros, pero no siempre son tan precisos como los números enteros. Por lo tanto, los números de coma flotante tienen más rango y menos precisión. Así que los números enteros son perfectos, pero hay un límite, como cuatro mil millones o cuatro billones o algo así, hay un límite. No te preocupes demasiado por eso. Hay una elección que debes hacer. Sueles usar números de coma flotante para cosas como la temperatura o la velocidad. Resulta que no se usa el punto flotante para obtener dinero. No se usa para obtener dinero, aunque en nuestros primeros ejemplos, seremos malos y lo usaremos para obtener dinero. Pero, caramba, no le digas a nadie que utilizo el punto flotante para hacer dinero. Si quieres, puedes jugar con la coma flotante y empezar a encontrar cosas en las que el dinero sale mal. Vale, en realidad hay una serie de tramas cinematográficas diferentes que tienen que ver con programas de ordenador que utilizan la coma flotante para obtener dinero. Creo que Office Space es una de ellas que me gusta especialmente, pero también hay otras. Por qué no se usa el punto flotante para obtener dinero, nos hemos desviado un poco en eso, pero está bien. Así que también tenemos un conjunto de funciones integradas que pueden convertir de un tipo a otro. Está float, está int. Así que float es una función y, de nuevo, tiene paréntesis. Pasamos por 99. Entonces, mientras se evalúa esta expresión, tiene que llamar a float. Pone 99 y, a continuación, lo que devuelve es 99.0, que es una representación en coma flotante del número 99. 99 y 99.0 no son lo mismo. Se trata de un número de coma flotante. Entonces, cuando ocurre esta suma, produce 199,0, por lo que es un punto flotante de 199,0. Al llamar a float, estás obligando a convertirlo en un número de coma flotante. Si vemos que i es 42, preguntamos de qué tipo es, bueno, que i es un número entero, podemos tomar una variable y pasarla a la función flotante y obtener 42,0 y 42,0. Y decimos ¿qué tipo de cosa es una f? Bueno, f es un flotador. ¿Verdad? Así puedes ver cómo manipulamos el tipo de cosas y las controlamos. Y cada vez que nos confundimos un poco, usamos la función de tipo y decimos: oye, ¿qué pasa aquí? ¿Por qué no entiendo lo que está pasando aquí? La división de enteros es algo que en realidad cambió entre Python 2 y Python 3. Es uno de los cambios más importantes, los mayores cambios no compatibles con versiones superiores entre Python 2 y Python 3. Así que esto, solo lo estoy reseñando. Hay algunas cosas que eran diferentes en Python 2. Así que 10 dividido por 2, incluso si ambos son enteros, produce un resultado de coma flotante. Esto no hace mucha diferencia si son divisibles de manera uniforme. Pero si no son divisibles de manera uniforme, hay una gran diferencia. Así que 9 sobre 2 es 4.5. Imagina que si dieras 9 dividido por 2 en una calculadora, no esperarías que dijera 4. Y en Python 2, decía 4, en realidad se truncó, de hecho, tiró esta parte a la basura. Pero en Python 3, convierte automáticamente las divisiones en coma flotante, por lo que funciona bastante bien, ¿de acuerdo? Así que 9 sobre 2 es 4.5. En Python 2, esto solía ser 4. Y entonces 99 sobre 100 es 0.99, exactamente lo que cabría esperar en Python 3. En Python 2, eso era un 0. ¿Por qué? Porque se truncó. Ni siquiera redondeó los números, los cortó. Así que este era realmente un artefacto bastante tonto de Python 2. En Python 2, si te quedas atascado en Python 2, solo usarías números de coma flotante. Y una vez que uno de los lados de la división o de cualquier otra operación sea un número de coma flotante, el cálculo se realizará en coma flotante. Por lo tanto, si es una entrada de punto flotante en cada lado, entonces es una salida de punto flotante. Y esto es lo que solíamos hacer en Python 2: forzar a las cosas a flotar si hacíamos divisiones. No estaría de más hacerlo en Python 3, pero ahora la división de enteros en Python 3 tiene mucho más sentido, gracias a Dios. De acuerdo, conversiones de cadenas. Así que si leemos datos, que veremos en un segundo, del mundo exterior vienen en forma de cadenas. Ya sea que los leamos desde una red o desde una base de datos, tendemos a obtener estas cosas como cadenas. Así que lo que mostramos aquí es un valor de cadena que es 123, pero en realidad no es 123, son tres caracteres. También podría ser A, B, C, así que 1, 2, 3 son los tres primeros caracteres. Entonces, tomamos esta constante de cuerda, la ponemos ahí y decimos, vale, qué tipo de cosas hay ahí. Es una cadena. Y si intentamos agregarle 1, como vimos antes, agregamos una cadena y un entero y Python se vuelve muy infeliz. No se puede convertir un objeto int en cadena de forma implícita. Pero, ¿qué pasa si sabemos que dentro de esta cadena hay en realidad dígitos y queremos obtener una representación entera, o una representación de punto flotante de eso? Bueno, en ese caso podemos llamar a la función int, o a la función float, pasando una cadena y obteniendo un número entero. Básicamente, esto lee estos caracteres, el 1, el 2, el 3 , y dice 123 y nos devuelve 123. Y decimos, ¿qué tipo de cosas hay ahí? Bueno, ahora, en Rival hay una pista. Ahora estoy siendo mnemotécnico. Recuerdo que se trata de un número entero y de una cadena, pero a Python no le importa el nombre que le dé a mis variables. Recuerda que a Python nunca le importa el nombre que le doy a mis variables. Así que, si empiezo a nombrarlas de manera conveniente, no pienses de repente que todo lo que comienza con el prefijo i es un número entero, y todo lo que comienza con el prefijo s es una cadena. Serán varias conferencias antes de que deje de recordártelo. Así que, ival termina con un número entero, el número 123. Y ahora podemos agregarle 1, porque es un número entero y Python es feliz, y el resultado es 124. Por lo tanto, esto funciona bastante bien a menos que la cadena en cuestión no tenga dígitos. Así que, si no hay dígitos, va a explotar, es como: guau. Ahora, vamos a leerlo. Rastrearlo significa que renuncio. ¿Dónde? La línea 1, siempre es la línea 1 porque estamos en este entorno interactivo. Pero si estuvieras en un guion, te diría de qué línea se trata. Y luego dice: literal no válido para int () con base 10: 'x'. Y eso es como, vale, no funciona muy bien. Y entonces, ya sabes, dirá que es una carta inválida. Y, de nuevo, encontraremos formas de hacer frente a esto en conferencias posteriores. ¿Está bien? Ahora, ¿cómo obtenemos datos del mundo exterior? Así que, este es el teclado, eventualmente hablaremos con redes, bases de datos y archivos. Pero ahora mismo, queremos tomar las teclas del teclado y convertirlas en una variable. Así que tenemos otra función, una función especial, la función de entrada. Y cuando Python se ejecuta aquí, inicia la función de entrada, y el parámetro de la función de entrada es lo que se llama indicador. Imprime quién eres, y luego espera, y luego escribimos en el teclado, Chuck, y luego presionamos la tecla Enter. Y luego toma esta cadena justo aquí, y luego la coloca en esta variable justo aquí. Es una cadena. Incluso si escribiera 1, 2, 3, 4, sería la cadena 1, 2, 3, 4, no 1234. ¿Está bien? Y entonces, ese es el camino. Y así, este programa en este punto hace una pausa hasta que escribamos y pulsemos la tecla Enter, y luego coge esa línea de entrada, incluidos los espacios, todo lo que escriba, y la coloca en esa variable. Y luego el programa continúa. Y en este caso, solo imprime la bienvenida, la coma y, a continuación, el contenido del nombre de la variable. Y en este caso, este espacio justo aquí que ves entre welcome y Chuck, está causado por esta coma. La mayoría de las veces hemos visto que imprimir significa imprimir una cosa, pero puedes tener tantas cosas como quieras con comas impresas, y cada coma añade un espacio, por lo que es bastante fácil de usar. Si quisieras, tendrías que concatenar estas cosas para eliminar ese espacio, pero lo más habitual es que cuando imprimas una lista de cosas, probablemente prefieras tener espacios entre ellas. ¿Vale? Así es como leemos las entradas. A continuación, combinaremos todas estas cosas y crearemos nuestro primer programa que haga algo realmente útil. Así que nos vemos en un rato.