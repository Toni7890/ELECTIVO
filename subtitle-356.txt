Bienvenido al capítulo 10. Vamos a hablar de las tuplas y, en cierto modo, ya conoces las tuplas. Las tuplas son una versión limitada de las listas, y la suma total de esto es que las tuplas son una especie de versión más eficiente de las listas que no puedes modificar. Así que en realidad son listas que no se pueden modificar. Así que esta es solo la sintaxis de las tuplas, pero se parece exactamente a las listas, excepto que vamos a usar paréntesis. Así que aquí hay una tupla de tres. El concepto de tupla, la palabra tupla proviene de las matemáticas. 2 tuplas, 3 tuplas. Una tupla de 2 es algo que tiene dos cosas. Es una forma de llamarlo así: 3 tuplas. Básicamente es un conjunto de tres cosas. Así que esta es una tupla de 3 con tres cadenas. De nuevo, se ve exactamente como una lista, excepto que usa paréntesis. Usamos el operador de índice x sub 2. Podemos usar la sintaxis constante. Asignamos estas cosas y la impresión solo las imprime con la sintaxis constante. Y simplemente no tiene corchetes, sino paréntesis. Cosas como max, usan tuplas. Analiza una secuencia de cosas. Las listas son una secuencia, las tuplas son una secuencia, una cadena es una secuencia. Así que Max los revisa, y el bucle for básicamente crea la variable de duración y luego rebota entre las cosas que están en una tupla. Y en cierto modo son lo mismo, ¿verdad? Ahora hay diferencias. El lugar donde hay diferencias es que las tuplas no se pueden cambiar. No, son inmutables. Y si recuerdas, las cadenas tampoco son mutables. Entonces, si echamos un vistazo, si tenemos una lista, 9,8,7, y podemos cambiar x sub 2 a 6, y luego eso cambia el 7 por un 6, las listas son mutables. Aquí tenemos la cadena de tres caracteres ABC, y queremos hacer el carácter 2 y convertirlo en una D, con esta sentencia de asignación. Y Python dice que no, no se nos permite hacer eso, es un rastreo. Y lo mismo ocurre con una tupla en la que queremos hacer z sub 2=0. Y dice que lo siento, no puedes cambiar. Así que no son mutables. Entonces, la diferencia es que las listas son mutables y, por lo tanto, las cadenas y tuplas no lo son. Pero eso es parte de la eficiencia de las tuplas, es que no son mutables y eso permite que se almacenen de forma más densa que las listas. Por eso, hay un montón de cosas que no se pueden hacer con las tuplas. No puedes ordenar una tupla. Sea cual sea el orden en el que pongas la tupla al crearla, permanece en el sentido de que no puedes agregarla, no puedes extenderla, no puedes voltearla con el reverso. Hay muchas cosas que no funcionan. Y si echas un vistazo a la salida del directorio, de listas y tuplas, verás que es un subconjunto. Puedes contar e indexar. El recuento busca cuántas cosas coinciden con un valor determinado. ¿ El índice dice dónde está un valor en particular? Pero no puedes agregar o extender o insertar, mostrar o eliminar, porque todos esos métodos dentro de las listas que no tienen las tuplas son los que hacen cambios en ellas. Así que está prohibido. Pero también permite que Python sea más eficiente, sabiendo que las tuplas no se van a cambiar. Listas que realmente tienen que asignar memoria adicional y cosas así para poder cambiarlas. Así que ese es el punto. No tiene que construir estas estructuras para que sean modificables, por lo que son más eficientes y tienen más rendimiento que las listas. Si necesita una lista, utilice una lista. Pero si puedes salirte con la tuya con una tupla, tendemos a usar tuplas, especialmente si vamos a crear una variable por un breve momento y luego desecharla. Ahora, hay un par de cosas interesantes que podemos hacer con las tuplas. Y una es que puedes poner una tupla en el lado derecho de una declaración de asignación. Ahora bien, ambas tienen que ser variables en este caso. Ahora, eso es muy diferente a poner una tupla en el lado izquierdo. Si lo pongo en el lado izquierdo de x e y, sería, x es 4 e y es 6, y eso es una tupla de 4,6. Pero si lo colocamos en el lado derecho, básicamente espera una tupla en la mano izquierda. Quiero decir, si lo colocamos en el lado izquierdo, espera una tupla en el lado derecho y luego hace una correspondencia uno a uno. Es lo mismo que decir que x=4 e y es igual a comillas sin comillas. Así que es una especie de declaración de asignación simultánea. Podrías escribir esto con x=4, y es igual a fred, ¿verdad? Eso estaría bien. Pero puedes hacerlo, lo veremos en un segundo, sea cual sea el orden. Ahora bien, esto podría ser una expresión o incluso una función que devuelva una tupla, y luego puedes asignarla a dos variables al mismo tiempo. Ahora, si haces algo como a, b=9, va a estallar en eso. Va a ser, no estoy contento con eso, porque espera que haya una tupla en este lado. Tiene que haber una tupla en ese lado. Y en este caso, si pongo nueve aquí, no hay tupla en ese lado. De hecho, ya hemos jugado con esto sin siquiera darnos cuenta. Por lo tanto, la forma en que esto funciona es que, si recuerdas los elementos d, los elementos te dan una lista de tuplas. Así que este diccionario tiene dos cosas. Csev se asigna a 2 y cwen se asigna a 4. Así que, si decimos objetos d, decimos que me des las tuplas, ¿verdad? Y así vuelven las tuplas. Así que esta es una lista de tuplas. Ahora, lo que sucede es que así es como funciona la variable cuatro de dos iteraciones. Y esta es una lista de 2 tuplas. Entonces, lo que sucede es que la primera pasa a la k y la segunda a la v. Esto es como una declaración de asignación para esta primera tupla. Luego ejecuta el bucle, y luego el segundo se coloca en la k y la v. Luego vuelve a ejecutar el bucle. Y así es como construimos estas dos variables de iteración para bucles usando tuplas, porque resulta ser una asignación de tuplas cada vez a través del bucle for. Ahora, una cosa interesante que pueden hacer las tuplas es que podemos compararlas. Recuerda que podemos comparar cadenas. Entonces, la forma en que funcionan las tuplas es haciendo la comparación, comenzando por la más a la izquierda y comparándola. Entonces, si hace la pregunta, ¿es inferior a? Bueno, 0< 5. Y en ese punto no mira más allá, del 0 y del 5. Es el elemento más significativo de la tupla. El dígito más significativo de un número, si está en 199 < 201. porque si hay un 1 allí y el 2 allí, entonces el resto de estos números realmente no importan, porque ese es el dígito más significativo. Así es como funciona esto. No los mira. Por otro lado, si el primero coincide y dice: ¿es inferior a? Luego tiene que mirar la segunda. Dice: 1< 3. Nunca mira este, y no mira aquel. Pero nos devuelve la verdad. Lo mismo ocurre con las cadenas. Está comparando cadena por cadena. Compara estos dos, y son lo mismo. Así que tiene que mirar a Sally y Sam, y luego a Sa. Bueno, son lo mismo, así que Sa. Y luego, en algún momento, están la l y esa m. Y entonces, la l es menor que m. Y por eso todo esto es cierto. Jones, Sally, es menos que Jones Sam. Si, por otro lado, las dos primeras no coinciden, Jones Adams, entonces nunca mira la segunda pieza en absoluto. No molesta porque la j es mayor que la a, por lo que esto se hace realidad. Así que está dentro de las cuerdas, busca el primer par, y luego dentro de eso, si no son lo mismo, y luego pasa al segundo par, al tercer par, lo que sea, y por eso es bastante inteligente. Así que esa es una de las cosas buenas de las tuplas. Y vamos a usar esto en un momento para clasificarlos. Por lo tanto, puedes pensar que las tuplas se pueden ordenar, por su primer elemento y, si el primer elemento coincide, luego mira el segundo elemento. Entonces, si volvemos a mirar los artículos, ¿qué sale? Pero si miramos los elementos del diccionario, los elementos d, obtenemos una tupla, a,10 c, 22, b, 1. Ahora lo que podemos hacer es decir: oye, nos gustaría hacer una copia ordenada de esto. Pasamos esto a la función de clasificación y obtenemos una lista ordenada, pero ordenada en función de lo primero. Porque en los diccionarios no puedes tener dos claves, no puedes tener claves duplicadas, ¿verdad? No puedes tener 2 A o 2 B. Así que lo clasifica en función de eso. Si coinciden, se fijará en el segundo. Pero en este caso particular, dado que proviene de un diccionario, estas claves van a ser únicas. Por el hecho mismo de construir el diccionario, no puedes poner la misma clave más de una vez. Puedes poner el mismo valor en más de una vez, pero no puedes poner la misma clave más de una vez. Básicamente, ordenada está esta función que toma una secuencia, y en cierto modo funciona a través de la función y te devuelve una lista que es la versión ordenada de esa función. Y así podemos escribir y componer esto, en un bucle for de la siguiente manera. Por lo tanto, los artículos ordenados nos darían los artículos sin clasificar. Pero si decimos ordenar y pasamos d elementos, entonces tenemos una secuencia que está ordenada por orden de claves. Así que k y v van a revisar este diccionario en orden de claves, no en orden de valores, en orden de clave. Así que esta es una forma de decir: quiero revisar este diccionario, en orden clave. Y eso es lo que va a salir. Por lo tanto, va a imprimir el ABC, independientemente del orden en el diccionario. Lo ordenamos antes de recorrerlo. Y así es como vamos a poner esto en orden. Pero no por orden de valor. Ahora, vamos a ver rápidamente cómo ordenamos por valor, ¿de acuerdo? Así es como ordenamos por clave. Es muy fácil, pero se necesita un poco más de trabajo para ordenar por valor. Pero vamos a usar tuplas. Así es como lo hacemos. Por lo tanto, si pensamos en esto, podemos obtener tuplas de valores clave, y todo lo que tenemos que hacer es crear tuplas de valores clave. Y si podemos hacer una tupla donde el valor esté primero y la clave esté en segundo lugar, entonces estamos bien. Así que lo que vamos a hacer es crear un bucle que analice estos elementos, sin ningún orden específico. En este caso, no estamos usando sorted here. Así que no es un pedido cualquiera. Así que k y v se abrirán camino a través de estos pares de valores clave. Y lo que vamos a hacer es crear una nueva tupla, pero vamos a invertir el orden de lo que obtendríamos de los objetos. En eso, el valor va a ser el primer elemento o el elemento cero de la tupla y k va a ser el segundo elemento. Por lo tanto, si imprimimos esto, no están particularmente ordenados en este momento, pero tenemos los valores y las claves. Clave de valor, clave de valor, ¿verdad? Valor, clave, clave de valor. Ahora lo que podemos hacer es decir que esto ahora es solo una lista. Es una lista de tuplas. Y si le decimos que se clasifique, comparará estas cosas y luego las clasificará. Y cuando coinciden, ahora los valores pueden duplicarse. Entonces, después del duplicado, hay un valor coincidente y, a continuación, la clave será la siguiente cosa en función de la cual ordenar. Así que vamos a llamar a sorted de nuevo y vamos a pasar temp, que es nuestra pequeña lista que acabamos de hacer, de 2 tuplas, clave de valores invertidos. Y vamos a dar un parámetro adicional, por ejemplo, ir hacia atrás. Así que ordene de mayor a menor, lo inverso es igual a verdadero, eso es lo que hace. Solo tienes que añadirlo como parámetro. Invertir es igual a verdadero a ordenado, y luego lo imprimimos. Así que ahora son 22, 10, 1. Así que va de grande, valioso, a pequeño, ¿de acuerdo? Así es como se obtiene una clasificación por valor en lugar de por clave, ¿de acuerdo? Pero tenemos que hacer una lista temporal. Por lo tanto, la temperatura es una lista, porque tenemos que agregarla. Pero cada una de las cosas de la lista es una tupla. Así que terminamos con una lista de tupla, tupla, tupla. Vale, de nuevo se trata de estructuras de datos. Estamos intentando crear formas de datos que nos ayuden a resolver nuestro problema. Ahora vamos a resolver un problema, las diez palabras más comunes. En el capítulo anterior, elegimos la palabra más común, pero ahora queremos las diez palabras más comunes. Así es como lo hacemos. Así que ya lo hemos hecho antes. Abrimos un archivo, creamos un diccionario. Repasamos todas las líneas del archivo. Dividimos las palabras del archivo. Así que tenemos un archivo con este aspecto, ¿verdad? Recorremos las líneas del archivo y luego, para cada línea, recorremos las palabras. Ese es el bucle exterior y el bucle interior. Y luego hacemos este recuento, obtenemos la palabra 0 + 1. Y eso crea nuestro pequeño conjunto de histogramas basados en cada palabra. Y los histogramas se hacen más altos. Y ahora lo que tenemos es que al final, aquí mismo, tenemos el histograma completo, sin ningún orden en particular. Ahora lo que vamos a hacer es extraer los datos de ese diccionario, los datos del histograma del diccionario. Y vamos a hacer una tupla inversa del valor, una tupla de palabras clave en lugar de un valor clave. Así que hacemos lo que acabamos de hacer en la diapositiva anterior. Escribimos un bucle para. Y aquí me va un poco diferente. Vamos a analizar el valor de la clave, pero luego voy a crear una tupla que sea la clave de valor y ponerla en la variable nueva tupla. Esta es una tarea de tuplas que va a entrar ahí. Y luego voy a añadirlo a la lista. Y así terminamos con esta lista, al igual que en la página anterior, una lista de tuplas en orden de clave de valores. Ahora, estoy bien, vamos a ordenar eso al revés. Así que estas son las tuplas de claves de valor, ve hacia atrás. Y luego reasignamos este resultado ordenado de nuevo a la variable de lista. Una vez hecho esto, se ordenará desde el valor más alto hasta el valor más bajo. Y ahora, tenemos que hacer dos cosas. Busquemos los diez primeros y tendremos que voltearlos cuando estemos imprimiendo. Así que esta lista ahora está al revés. Es v, coma k, valor, coma k, y vamos a usar la división de listas. Por lo tanto, estamos diciendo que comience por el primero y suba hasta diez, pero sin incluirlo. Así que son del 0 al 9, que son los primeros 10. Y notarás que este dial y esta tecla están invertidos. Y eso es porque en él, el valor es la primera pieza de cada tupla y la clave es la segunda parte de cada tupla. Y así, pasará sucesivamente por clave de valor, clave de valor, clave de valor, clave de valor, clave de valor. Pero solo pasará por los 10 primeros porque lo hemos limitado con la división de listas. Y luego lo imprimimos en el orden en que queremos que lo vea en primer lugar. Así que vemos una especie de cambio de orden, entre la forma en que iteramos a través de la estructura de datos y luego la forma en que imprimimos este material. Y eso nos devuelve al valor clave, que es lo que queremos. Y eso es algo bastante sofisticado. Estamos usando diccionarios, estamos usando listas y estamos usando tuplas y ordenando. Y ese es un bonito pedacito de código. Una vez más, le animo a que comprenda cada línea de este código. Por lo tanto, la siguiente diapositiva no es algo que insista en que entiendan, pero algunos de ustedes pueden encontrar esto fascinante. Así que puedo hacer con eficacia esta parte inferior aquí, no el cálculo, sino la parte inferior allí mismo. Puedo hacer todo esto en una línea de código, que toma el diccionario y luego termina con la tupla ordenada por orden de valores. Y esto es todo. Deja que lo mires un segundo. Utiliza una parte de Python llamada comprensión de listas. Entonces, lo difícil aquí es esta sintaxis en el medio, que parece una lista y es una lista. La diferencia es que, en lugar de expresar la lista con anexos o como una constante con comas, expresamos la lista como una expresión. Y me gusta leer esto como si estuviera aquí, solo para decirlo en nombre de todos. Créame tuplas que sean v coma k. Y te darás cuenta de que este orden es: tengo la clave de valor v coma k, tuplas 4. Es como si hubiera un pequeño bucle que ocurre aquí. Va a acabar con un montón de estas pequeñas tuplas. Estampilla, estampilla, estampilla, estampilla, estampilla. Y va a estampar lo suficiente como para pasar por cada kilogramo que esté en los objetos C. Así que ese es el valor clave de este diccionario. A 10, b 1, c 22. Esto se ejecutará tres veces. Hará tres tuplas, pero esta lista las invertirá. Así que este pedacito de aquí, este pedacito entre corchetes, es el mismo que este pedacito de aquí. Básicamente es lo mismo que hacerlo, excepto que se expresa de una manera más directa pero un poco más compleja. Así que esta es una lista que se calcula sobre la marcha, es una lista de tres tuplas, invertida con valores y claves. Y luego, paso esto directamente a sorted, a la función sorted. Así que son paréntesis de funciones ordenadas. Y luego tomo lo que no está ordenado, que es esto, y lo paso a la impresión. Y me olvidé de poner lo contrario igual a verdadero aquí. Así que sale, pero no se invierte. Es una clave de valor pero no está invertida. Así que entiendes la idea. Así que si estás muy, muy interesado en esto, lee un poco sobre la comprensión de las listas. Es una forma interesante y poderosa de hacer que Python sea aún más conciso. Pero no dedico demasiado tiempo a hablar de ello, porque si ves esta versión y sientes que esa versión tiene mucho más sentido para ti, quédate con ella. Si esta versión tiene mucho más sentido para ti, úsala. Quiero decir, una vez que lo haces bien, ambos te hablan por igual. Pero probablemente sea más fácil si estás empezando a usar primitivas más simples. Y aquí, una vez que seas más sofisticado usando una especie de estas primitivas más poderosas, ¿de acuerdo? Así que eso es un recorrido rápido por las tuplas, hablamos sobre cómo son más o menos como listas. No puede cambiarlos, puede compararlos, se pueden ordenar y puede tener los dos valores que figuran en una declaración de asignación. Y ahora podemos ordenar los diccionarios por clave y valor construyendo una estructura de datos, es decir, una lista de tuplas invertidas, y luego ordenarla, y usarla para ordenar, está ahí para nosotros. Y si podemos configurar los datos de manera que la clasificación haga lo que queremos, entonces obtenemos los datos que queremos y realmente estamos aprovechando las estructuras de datos.