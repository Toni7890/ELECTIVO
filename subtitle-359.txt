Bienvenido de nuevo. Continuaremos con nuestro tema del conteo en histogramas. Pero contar las cosas que están en una lista, cinco elementos en una lista, es demasiado fácil, tenía esos ejemplos, muy simples. Ahora, lo que vamos a hacer es tomar un texto del libro de texto y vamos a contar un poco. Una vez más, esto es algo recurrente. Hablamos sobre la palabra más común, etc. Vamos a contar el texto y, una vez que descubras cómo hacerlo, es bastante sencillo. Puedes contar un millón de palabras tan fácilmente como puedes contar cuatro palabras. Este es un programa muy simple que tenemos en el que vamos a contar las palabras en una línea de texto. Creamos un diccionario, pedimos al usuario que introduzca una línea de texto, lo leemos sin preguntar y luego lo dividimos en espacios en blanco como hemos hecho antes, y luego la variable words ahora es una lista de las palabras que estaban en esa línea con espacios. Solo tenemos un bucle que los atraviesa. No es tan diferente al ejemplo anterior, simplemente leemos una línea de entrada y la dividimos en palabras y, a continuación, recorremos las palabras en bucle y, a continuación, contamos que la subpalabra es igual a counts.get (word0) +1, que es la expresión que se utiliza para crear una entrada de histograma y, en la misma línea, incrementar implícitamente ese histograma. Ahora tenemos un histograma. Es así de sencillo. Si ejecutamos este código correctamente, que es algo de lo que hemos hablado antes, este es el que es más difícil. Cuenta la palabra más común y cuántas veces. Los hice verdes para poder ir como 1, 2, 3, 4, 5, 6, 7, puedo hacerlo. Pero si no son verdes, es muy difícil. Pero lo que mola es que es para Python, es muy fácil. Obtenemos esa línea de texto, cortamos la división, obtenemos una lista con las palabras con todos los espacios en blanco eliminados. Y luego tenemos un bucle a favor y luego hacemos los recuentos. Una vez que entiendes ese modismo del histograma, es bastante fácil construir estas cosas. Introducimos nuestra línea de texto, la dividimos, obtenemos la lista de palabras, creamos un histograma vacío y, a continuación, recorremos las palabras de la lista y, a continuación, aumentamos el histograma, creando entradas y añadiendo una a esas entradas. Hemos estado revisando las listas, pero eventualmente, necesitamos revisar los diccionarios. Ponemos cosas en los diccionarios. Todo lo que hemos hecho hasta ahora en este capítulo es imprimirlos todos. Tenemos que pensar en revisar los diccionarios. Empezaremos con una simple constante de diccionario. Chuck mapea a uno, Fred mapea a 42 y Jane mapea a 100. Puedes usar el estándar para claves y recuentos, y eso se repetirá. Pero lo que va a hacer es ir iterando las claves porque cada entrada, a diferencia de lo que ocurre en una lista, es un par clave-valor. Si vas a correr en bucle, te quedas con las llaves. Pero está bien porque, dentro del ciclo, puedes ir al diccionario y extraer el valor con la subclave clave count. Si imprimo la clave y cuento la subclave, verás que el bucle se ejecuta tres veces, como Chuck 1, Fred 42, Jane 100. Es un problema que solo revises las teclas. Si lo piensas bien, no podrías revisar los valores porque no puedes buscar la clave a partir del valor. La otra cosa acerca de los diccionarios es que la implementación subyacente basada en hash significa que, en cierto sentido, se garantiza que la subclave counts sea eficiente incluso cuando hay millones de entradas en un diccionario. La subclave de recuento es rápida. Si fuera una lista y tú incluyeras alguna lista inferior a 12, eso también es rápido. Parte de lo que hacían cuando creaban listas y diccionarios era crearlos de manera que, si los usas y los usas de la manera correcta, de la manera normal, esas cosas son rápidas porque las implementaciones que hay debajo de las listas y los diccionarios están diseñadas para que las cosas comunes que hacemos busquen por posición y listas y busquemos por clave y diccionarios sean rápidas, lo que significa que no requieren mucho tiempo de procesamiento. Porque, de nuevo, esto no es para tres entradas, es para un millón de entradas o 10 millones de entradas. Cuando no estás haciendo ciencia de datos o lo que sea. Por cierto, un patrón de bucle consiste en poner los conteos al final de un patrón de cuatro, y la clave es una variable, no tiene ningún significado, pero es una muy buena elección de variable porque a estas cosas las llamo pares clave-valor. Veremos más adelante que usaré el valor del nombre de la variable a veces. Ahora hay otros métodos dentro del diccionario que pueden extraer cosas. Si, por ejemplo, tomas un diccionario, en este caso jjj con tres pares clave-valor, y lo conviertes o lo conviertes en la sublista que dice jjj, toma lo que hay en este diccionario y devuélvemelo en forma de lista. Al igual que el bucle que acabamos de ver, te devuelve las llaves. Te devuelve una lista de las llaves. Hay otra sintaxis que es el método keys, por lo que ves jjj.keys (), es decir, llama al método keys y todo eso de los paréntesis significa que realmente estás llamando al código que se encuentra dentro del objeto del diccionario. Diríamos que las claves son un método que tienen los diccionarios jjj.keys es exactamente lo mismo que convertir en una lista. Como jjj.keys devuelve una lista, vemos exactamente lo mismo. Puedes decir jjj.values () y eso te dará una lista de los valores básicamente en el mismo orden de las claves. En este caso, dicho sea de paso, las claves y los valores no son algo que haya elegido como programador, ya que forma parte de la documentación del diccionario que dice que hay un método de claves y hay un método de valores y esto es lo que hacen. Ahora vimos cómo podíamos usar las llaves. Revisa las teclas y luego busca el valor cada vez que recorres el bucle. Pero también puedes decir: mira, los quiero a los dos. Hay otro método llamado items y que devuelve una lista de lo que llamamos tuplas. Las tuplas ya no son pares de valores clave. Tuples es el siguiente capítulo, casi piense en ellas como listas de solo lectura. Son solo listas que tienen dos cosas en orden. Eso es con los paréntesis, el corchete es una sintaxis de lista. El corsé rizado es una sintaxis de diccionario. El paréntesis, cuando hay una lista de cosas, es una tupla. Esto, una vez que tienes una tupla, jjj.items, devuelve una tupla, que es una lista de los pares clave-valor. Esta sintaxis no está presente en ningún otro lenguaje de programación común que conozca. Me encanta esta sintaxis. Es decir, tenemos dos variables de iteración. En este caso, las dos variables de iteración que tengo son aaa y bbb. Significa que aaa y bbb juntos recorren el diccionario. Revisa los elementos sucesivos del diccionario. Obtienes ambos, por lo que no tienes que buscar el valor en este caso, porque bbb es siempre el valor y aaa siempre es la clave a medida que avanza en la lista. Probablemente estoy haciendo demasiado alboroto por esto porque solo imprime Chuck 1, Fred 42 y Jan 100. Se convierte en un modismo como el que acabas de decir ahora que no llamaría a estos valores aaa y bbb. Lo hago para que no te confundas. Yo nombraría la clave y el valor. Yo haría que las variables de iteración fueran clave, valor en jjj.items. Eso es lo que haría. Pero tengo la sensación de que eso te confundiría ahora mismo, así que no vamos a hacer eso. Pero cuando escribas tu código, siéntete libre de usar la clave y el valor. La clave es que esto es algo que veremos en el próximo capítulo, es lo que se llama asignación de tuplas. Creo que es una de las cosas más bonitas que hace Python. No me gusta, Java no lo hace. Php no lo hace. Javascript no lo hace porque no tiene un concepto de tuplas. Creo que, lista diccionarios y tuplas. De nuevo, estoy pensando en el próximo capítulo. Pero las tuplas, creo, son una adición muy elegante que no tienen muchos otros lenguajes de programación. Así que mira lo hermoso que es esto y debes saber que probablemente sea la última vez en tu carrera que verás un circuito de cuatro bucles tan hermoso como este. Entrarás en Java y pensarás : oh, los cuatro bucles de Java son terribles. ¿Por qué no lo hacen como Python? Solo me estoy depilando, elocuente. Este es un precioso fragmento de código. De hecho, hay momentos en los que veo un fragmento de código y creo que es un fragmento de código hermoso porque es muy expresivo, es tan hermoso. Hay algunas cosas hermosas como el lenguaje C++. Hay muchas cosas que no me gustan de C++, tiene algunas cosas hermosas. Ahora, vamos a volver, vamos a volver al capítulo 1. Estamos sentados aquí, en el capítulo 9. Te dije que entenderías este código, que en el capítulo uno acabo de decir que no intentes entender esto. Pero hoy, ahora mismo, quiero que entiendas cada línea. Vamos a repasarlo. Pedimos un nombre de archivo. Lo abrimos, creamos un diccionario vacío y ahora vamos a recorrer el archivo. En el caso de la línea de entrada, el identificador recorre el archivo. Entonces, lo que vamos a hacer es dividir esa línea. Muchas líneas. Divide la línea, muchas líneas dividen la línea. Luego, para cada palabra de la línea, las haremos una línea a la vez. Pero luego cruzamos la línea cuatro palabras en palabras. Luego obtenemos modismos, recuento de subpalabras iguales a recuentos, puntos, obtenemos palabras cero más uno. Ahora tenemos un diccionario y es un histograma. Al final del primer ciclo de recuentos, tenemos todas las palabras y sus recuentos correspondientes, pero queremos encontrar la más grande. Vamos a hacer un bucle máximo. El bucle es un bucle máximo, tienes que tener un valor que empiece por ninguno y la palabra clave para contar palabras es una cadena y contar es un número entero. En el recuento, los elementos comienzan, si el recuento grande es ninguno, lo que significa que ese es nuestro pequeño truco que tenemos en los bucles máximos. Para el primero, el recuento grande comienza antes de que comience el ciclo sin ninguno. Eso va a significar que el primero es el más grande que hemos visto hasta ahora. O el recuento es mayor que un recuento grande, el recuento actual es mayor que un recuento grande. Eso está en la segunda y en la posterior. Estamos en esa única afirmación, estamos haciendo la primera iteración y la segunda iteración y las posteriores. ¿Qué hacemos como máximo? Si vemos algo más grande, o es lo primero que recordamos, decimos que una gran palabra es igual a una palabra y que un gran recuento es igual a un recuento. Luego, cuando ese ciclo pasa, la cuenta grande aumenta y la gran palabra es recordar la última palabra más grande que tenemos. Cuando todo esté hecho, tendremos la palabra más importante, la imprimiremos y listo. Esto es lo que prometí que sabrías en el capítulo 1, y ahora deberías saberlo. Te voy a dar una tarea que es más o menos esto, así que debes saberlo. Si no vas más despacio, no fue una revisión tan difícil, sea lo que sea que necesites revisar hasta que lo entiendas, yo diría que no vayas más allá hasta que realmente lo entiendas. En este capítulo, hemos hablado de las colecciones. Hemos hablado de listas versus diccionarios. Hemos hablado de las constantes del diccionario, las corchetes rizadas, las cosas con un valor clave, con dos puntos en el medio. La palabra más común es histograma. La expresión idiomática de get y los diferentes métodos dentro del objeto de diccionario que extrae cosas. Echamos un vistazo a continuación, vamos a hablar de las tuplas, y luego lo entenderás muy bien. Tienes que entender lo que tenemos aquí y luego pasar al siguiente capítulo. Luego revisaremos esto nuevamente en el siguiente capítulo, después de tener una definición muy precisa de lo que son las tuplas, y luego comenzaremos a ordenar las cosas. Este es un capítulo maravilloso, espero que realmente lo hayan entendido y nos vemos en el próximo capítulo.