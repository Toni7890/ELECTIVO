Ahora vamos a hablar de algunas de las operaciones que puedes hacer con las listas. Hemos estado hablando de su estructura interna, pero ahora vamos a empezar a trabajar con ellas. Así que lo primero que vemos aquí es que podemos sumarlos y es como concatenar cadenas. Concatenamos listas. Funciona prácticamente de la misma manera. Agregar a y b para formar c no perjudica ni a ni a b. Al operador de segmentación, piénsese de nuevo en las cadenas. Piensa en cortar. Piensa en la posición inicial hacia arriba, pero sin incluir, así que el sub 1 es esa posición justo ahí arriba, pero sin incluir el sub 3, que es 41, 12. Así que eso es lo que obtenemos allí. Al igual que con las listas, puedes omitir la primera para sumar 4, pero sin incluir, que es esta de aquí, así que este es el 0, 1, 2, 3, 4. Mentalmente tendrás que contarlo hasta el 4, pero sin incluirlo. Esa es esa. 3 hasta el final, así que 0, 1, 2, 3 es 3 hasta el final, así que son 3, 74 y 15. Y luego, al igual que con las cuerdas, puedes tener el principio y el final. Así que, de nuevo, se parece mucho a las cuerdas. La segmentación de listas es como la segmentación de cadenas, excepto que la lista divide celdas enteras dentro de la cadena. Al igual que en las cadenas tenemos muchos métodos de biblioteca, hay muchos métodos en el objeto de lista. anexar lo que añade una cosa al final de la lista. Cuenta lo cual, en realidad, len te dice cuántas cosas hay en una lista. contar te dice cuántas cosas que coinciden con una cosa en particular hay en una lista. extender, indexar, insertar, mostrar, eliminar, hay un montón de cosas y todas están muy bien documentadas en la documentación de Python. Así que usaremos un par de estas cosas. Hay un par de formas de crear una lista desde cero. A esto lo llamamos constructor y, por lo tanto, list es un tipo predefinido. Este es el tipo de lista. Así que decimos: haz una lista completamente nueva, es lo mismo que decir: dame una lista vacía y luego la asignamos a cosas. Así que esa es una lista que no contiene nada, así que su longitud es cero. Y luego decimos que agreguemos el libro de cadenas y luego agreguemos la cadena 99 y la imprimimos y ahora tenemos un libro con dos elementos, así que puedes hacer esto una y otra vez y agregar cosas si quieres. Y puedes seguir adelante. Podemos añadir la cookie de cadena. Así que al final de la galleta, tienes tres cosas ahí. libro, 99 y galleta. Así que adjuntar es un método. Ahora, recuerde que las cadenas no son mutables, por lo que todos estos métodos devolverían variables. Pero las listas son mutables, por lo que agregarlas cambia realmente esta variable. Ten en cuenta que las cosas son diferentes de aquí a aquí porque las hemos añadido, y eso se debe a que las listas son mutables, pero no las cadenas. Así que funcionan de forma un poco diferente, y justo cuando aprendes las cadenas, aprendes que es el valor devuelto. Así que, por ejemplo, no quieres hacer algo como x = x.append. Porque el valor de retorno que se obtiene aquí, el valor de retorno residual, en realidad estropea x. Así que no quieres hacer eso. Solo tienes que decir x.append y funciona mucho mejor. en. Una vez más, uno de mis operadores de Python favoritos está en. En las cadenas, se pregunta si un carácter o una subcadena estaba en otra cadena. Ahora estás viendo a los miembros de la lista y ¿estás diciendo que hay 9 en algún lugar de la lista? Sí, lo es. ¿15 está en algún lugar de la lista? No, no lo es. Y luego no está también un operador. Es lo opuesto a in, ¿así que 20 no está en la lista? Y la respuesta es que 20 no está en la lista, así que obtenemos True. Esa es solo una pregunta que puedes hacer en cualquier afirmación antigua que desees. Las listas mantienen el orden. El orden en que pones las cosas es el orden en que las sacas. Así que añade, añade, añade. Lo que sea que hayas adjuntado, aparecerá exactamente en el mismo orden. La lista lo mantiene. Son un poco densos y compactos, y solo se pueden añadir al final, aunque se puede decir que se empujan todos hacia abajo y se coloca algo en el medio con un inserto, si se quiere. Pero también significa que podemos ordenarlos. Por lo tanto, aquí tenemos tres cosas. Joseph, Glenn y Sally. Y decimos: «Hola amigos, arréglense». Esto está un poco más orientado a los objetos. Llamamos al método de clasificación dentro del objeto de amigos. Y ahora, se ha cambiado. ¿Verdad? Así que en realidad lo cambia. Así que ahora está en orden alfabético: Glenn, Joseph y Sally. Y el amigo sub 1 es el nuevo sub 1, así que esto lo cambia porque las listas son mutables. Tenemos muchas funciones. Ya hemos jugado con len y hemos hablado de len y de cuántas cosas hay en la lista. ¿ Podemos decir cuál es el número más grande de una lista? ¿Cuál es el número más pequeño de una lista? Súmelos todos. ¿Cuál es la suma de esta lista? La suma de la lista es 154 y puedes calcular el promedio a partir de la suma. Bien, algunos de vosotros volveréis al capítulo 5 y diréis, bueno, ¿por qué nos habéis dado todos esos cuatro bucles para hacer lo mismo en vez de simplemente decirnos esta función? Así que la respuesta es: bueno, hay razones para saber cómo construirlas para los bucles. Y eran buenos y fáciles de entender para los bucles. Si tienes una lista y es una lista de números, estos son mucho mejores que crear un bucle for. Así que todos esos ejemplos del capítulo anterior no son la forma en que se resolvería ese problema en particular. Pero a veces lees las líneas de un archivo y tienes que hacerlo de forma un poco diferente. He aquí un par de bucles que demuestran esta idea de cómo se pueden usar estas funciones para calcular un promedio en comparación con la forma en que calculamos un promedio en el capítulo anterior. Aunque en cierto modo lo rehago de una forma diferente porque ahora finjo que estoy leyendo desde un archivo, pero en vez de eso voy a leer desde una entrada. Voy a leer los números, puntos, puntos hasta que termine. Y voy a calcular el promedio de esos números. Así que es solo un bucle estándar en el que establecemos el total en 0 y contamos en 0. Voy a hacer un bucle de tiempo, si estuviera leyendo un archivo sería un bucle for, pero esto es, voy a pedir algo de entrada, a solicitarlo. Si ya está hecho, voy a salir del bucle para solucionar este caso y poder salir del bucle de alguna manera. Y luego calculo el valor de punto flotante de esa entrada, y lo sumo a mi total acumulado, y tengo mi conteo acumulado, count = count + 1. Y luego esto corre, ya sabes, en este caso tres veces, y luego viene aquí, calcula el promedio y lo imprime, y listo, ¿de acuerdo? Y esa es una especie de bucle construido manualmente con un contador construido manualmente y una suma construida manualmente y listo. Ahora, si tratara de usar el máximo y el mínimo para lograr exactamente lo mismo. Entonces, lo que haría es acumular estos valores en una lista. Así que ahora estoy usando una estructura de datos en lugar de solo la lógica. Así que este es un tipo de algoritmo que se construye cuidadosamente para producir el conteo y la suma cuando todo está dicho y hecho. Ahora, lo que vamos a hacer es usar la estructura de datos para resolver el mismo problema. Así que diremos: oye, hagamos una lista vacía porque vamos a acumular algunos números. Y luego tenemos el mismo bucle, las mismas dos líneas, buscamos en realidad las mismas tres líneas. Obtenemos un valor, comprobamos si hemos terminado, lo obtenemos y lo convertimos en un valor flotante. Pero ahora, en vez de hacer la suma como lo hacemos aquí, decimos que lo recordemos. Y tenemos esta lista, vamos a rellenarla, vamos a ponerle números. Así que ponemos un 3, ponemos un 9, ponemos un 5. Y luego, ponga un 3, ponga un 9, ponga un 5. Así que no, en realidad no estamos calculando ningún cálculo. Y luego, cuando terminamos, salimos y decimos: oh, calculemos el promedio. Bueno, ahora tienes estos números en una lista. Tenemos una lista que se parece a [3, 9, 5], eso es lo que hay aquí. Así que tomamos la suma de eso, y luego lo dividimos por la lente, y tenemos el promedio. Y este mismo programa produce exactamente el mismo resultado, ¿de acuerdo? De modo que ambas cosas producen el mismo resultado. Y puedes decidir por ti mismo cuál crees que es más elegante. En general, hay una pequeña diferencia entre estos dos. Y es que este tiene que tener todos los números en la memoria antes de poder hacer el cálculo. Esto solo mantiene un número en la memoria. Y eso probablemente no importe si hay cien mil números o menos, pero si hay cien millones de números, este no usa cien millones de espacios en la memoria y este sí usa cien millones. Por lo tanto, hay tamaños de datos que son lo suficientemente grandes como para importar, el uso de memoria entre estas dos cosas es importante. porque esto requiere dos variables para cualquier número. Esta de aquí requiere dos variables para cualquier cantidad de cosas que vayamos a hacer con el promedio. Y esto requiere un poco más de memoria para cada número. Por lo tanto, se escala en función de los números. Para las pequeñas cosas que estás haciendo, no importa. Y si de alguna manera ya tienes estos números en una lista, esta es una excelente manera de hacer una suma. No escribirías el bucle for para hacer la suma. Si ya tienes números en una lista, súmalos con una suma o calcula el máximo usando una función, está perfectamente bien. Así que eso es como manipular listas y escribir algunos bucles interesantes. Y ahora vamos a jugar con conectar listas y cadenas juntas.