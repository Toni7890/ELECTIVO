Hola y bienvenidos a Python para todos y a otro tutorial sobre el código. En este, vamos a ver un diagrama del capítulo 16. Vamos a echarle un vistazo. Esta es una situación en la que vamos a hablar con algunos datos de mapas de calles abiertos a través de una API, a través de un proxy para esa API, y vamos a escribir un poco de código que va a eliminar este material repetidamente. Ahora, estas API son notoriamente lentas, caras, difíciles y, a veces, incluso poco confiables. Si llegas a un límite de velocidad, empezará a repercutir en ti, por lo que queremos que este sea un proceso que se pueda reiniciar. Lo que vamos a hacer es escribir este código llamado geoload.py y va a leer un archivo que es la lista de las ubicaciones que, en última instancia, queremos tener. Cuando hagas tus deberes, tienes que editar este archivo. Pero la idea es que esta carga geográfica lea todas las ubicaciones que queramos y, a continuación, comience a desplegarlas y, a continuación, simplemente inserte el JSON en este archivo SQL light de datos geográficos. Entonces, esta parte aquí es un proceso que se puede reiniciar, la carga geográfica es un proceso que se puede reiniciar. Cuando lo hagamos, lo empezaremos un par de veces. Es lo suficientemente inteligente como para saber las cosas que ya tiene y no empezar desde el principio una y otra vez. Por eso es un proceso que se puede reiniciar. En cualquier momento dado, podemos, en cierto sentido, ver y visualizar el contenido actual de esta base de datos con geo dump.py. Eso lee la base de datos y produce un pequeño archivo llamado where.gs, también escribe un pequeño resultado de depuración y luego se lee ese where.js cuando se abre un navegador. Este archivo where.html se abre en un navegador y luego lee el where.js y luego lo visualiza y eso es genial. En algún momento, se supone que debes poner tu propia ubicación en where.data y luego mostrar en la visualización que has podido obtener tu ubicación. Sin más dilación, echemos un vistazo al código. El código que vas a necesitar usar es opengeo.zip. Descarga www.pyfree.com/code/opengeo.sip y luego lo abre en una carpeta y tendrá una carpeta llamada Opengeo. Si miro mi carpeta actual de Opengo, puedes ver que tiene texto rojo, geodum.py, geoload, where.data, where.html y where.js. Los archivos where.html y where.js son la parte de visualización, la carga geográfica es la parte de araña y el volcado geográfico es la lectura de la base de datos. Sigamos adelante y empecemos a echar un vistazo a geoload.py. Esta es la araña que se puede reiniciar y, si nos fijamos, estará buscando un proxy de la geoapi. Existe el mapa de calles abiertas y podemos buscar cosas en el mapa de calles abiertas, realizar esta geocodificación a mano y lo hacemos cada vez que hacemos una búsqueda en un mapa cuando se produce una geocodificación. Estamos hablando de GeoAPI, que de hecho toma los datos gratuitos, pero luego los envuelve en una API. Esta es la API que vamos a obtener, pero si la vas a usar, tienes que conseguir una cuenta. Así que tienes que inscribirte. Lo que he hecho para simplificar las cosas en esta clase es crear un proxy para ella. Este proxy no requiere una clave, pero tiene límites de velocidad de API realmente estrictos, lo que significa que se ralentiza terriblemente si lo usas más de lo que deberías usar en esta clase. Pero esa ralentización también es divertida porque estás haciendo algo que se puede reiniciar. No necesitas una llave para hablar de esto, es solo para esta clase. El protocolo es bastante sencillo. Tiene un parámetro de consulta que es la ubicación del texto correctamente codificada en URL, los espacios se codifican como signos positivos y las comas representan dos porcentajes. Ese es el tipo de cosas que tenemos que hacer. Si echamos un vistazo rápido a nuestro código y analizamos este código en una anterior, solo recuperamos uno, ahora estamos creando y reiniciando un proceso mediante una base de datos. Tenemos este prefijo. Ahora bien, esta es una base de datos, así que vamos a crear o abrir una base de datos existente y, en este caso, aún no tenemos una base de datos, ls-l, no hay ninguna base de datos. Verás que la primera vez que empecemos con esto vamos a crear esta base de datos y vamos a crear una tabla sencilla. Ahora, la clave es que todo lo que vamos a hacer es tomar la dirección que buscamos como clave y el JSON que obtenemos como valor. En este caso, Ann Arbor, Michigan, es la clave y estos datos sin procesar que se ven más bonitos, ese es el valor. Eso es lo que vamos a hacer porque, una vez más, este es el proceso que se puede reiniciar. Quieres que este proceso reiniciable sea sencillo y reiniciable. Luego, si continuamos con el código, vemos que los problemas de los certificados tienen que ver con el hecho de que no hay muchos certificados buenos que estén incluidos por defecto en Python, por lo que es más sencillo por ahora. En producción, puedes entender esto un poco mejor, pero solo asegúrate de que nuestro material de biblioteca de URL funcione. Ahí lo tienes. Es lamentable porque cuando arreglaron esto de que no les gustaban los certificados, tuvieron algunos problemas. Los acaban de sacar todos. Pasamos de tener muchos certificados buenos y uno malo a no tener ningún certificado válido y , de inmediato, todos ignoraron los certificados. La ley de las consecuencias imprevistas. Echemos un vistazo a este archivo, where.data. Where.data, la idea en algún momento es que quieras saber las ubicaciones. Esta es solo la entrada a R y estos son solo todos los lugares, y podemos agregar a este Jerk Pit, Ann Arbor, Michigan. Esta es la lista de tareas pendientes, en cierto sentido. Eso es lo que vamos a hacer y les doy un punto de partida y se supone que, en su trabajo, deben añadirle algo. Vamos a leer esto donde .data y ese archivo tenían, no recuerdo, 250, 75, pero puede que tengas miles de líneas. Luego leeremos todo el archivo y, si superamos las 100 ubicaciones de recuperación, nos detendremos y eso permitirá que nuestra API se establezca. Cambie estos números y, a continuación, cogeremos la dirección de la línea, que es solo una línea de texto, y luego comprobaremos si la dirección ya se ha recuperado. Estamos haciendo una codificación en una vista de memoria debido a UTF-8 y porque la base de datos está fuera de nosotros. Ahí lo tienes. Entonces, lo que vamos a hacer es recuperar ese registro. Si la dirección ya estaba en la base de datos, al principio no es porque la base de datos esté vacía, simplemente vamos a continuar haciendo zoom en este archivo, sin recuperar los que ya hemos recuperado y que ya están en nuestro archivo. Pero si no están ahí, vamos a crear una URL. Este es básicamente el patrón que vamos a crear en el diccionario, y vamos a decir que q es igual a Ann Arbor, Michigan, pero esa Ann Arbor, Michigan, tiene que estar correctamente codificada en URL. Eso es lo que hace este urllib.parse.urlencode. Eso termina con una URL que se ve así. Todo se concatena, pero esa codificación es algo para lo que no tenemos que escribir el código. Gracias a Dios, porque aunque es fácil de explicar con un ejemplo sencillo, es difícil hacerlo bien en todos los casos, así que dejaremos que las bibliotecas lo hagan. Ahora tenemos una URL, así que abrimos esa URL. Este pequeño context = ctx es el truco que utilizamos para ignorar los errores de SSL. Luego lo leemos. Pero lo que vuelve, por supuesto, es esto de aquí, si tuviéramos que mirar los encabezados, veamos. Podríamos mirar los encabezados y verías que se trata de una aplicación UTF-8/JSON. Python internamente no usa UTF-8. Python usa Unicode internamente, por lo que decode dice lo que acabamos de leer, UTF-8, lo decodifique en nuestro formato interno, que es Unicode, y listo. Luego publico una sentencia de depuración e incremento mi recuento para que cada ejecución no tenga más de 100. Luego intento analizarlo usando json.loads. Luego tengo que hacer un par de controles de cordura para asegurarme de que tengo datos reales. Si ni siquiera tuviera datos, simplemente tendría que quejarme y interrumpirlos o continuar. Luego lo insertaré en la base de datos. Inserte en ubicaciones, direcciones, geodatos, codifique la dirección y codifique los datos, y listo. Lo voy a cometer y voy a dormir cinco segundos todos, y eso da vueltas y vueltas y los recupera. Luego, al final del ciclo, imprime la cantidad de funciones y envía un pequeño mensaje. Sigamos adelante y ejecutémoslo. Parte de este código del que hablamos es una adaptación de hace un par de capítulos. Vamos a escribir Python geoload.py. Ahora empezará a leer where.data y a acceder a la API. Verás, ahí lo tienes. Ahora voy a pulsar «Control» y «C». Hizo los primeros 10 y luego tocó esto, y presioné «Control» y «C» para hacerlo estallar. Si buscamos en nuestra base de datos ahora, permítanme empezar con eso. Si miramos nuestra base de datos y abrimos una base de datos. ¿Dónde estoy? Tengo que encontrar dónde estoy. Tendrás que averiguar dónde estás. Solo lo tengo en los nombres de mis carpetas. Estoy trabajando bien en lo que más me importa. Ahí estamos Encontré ese archivo, por lo que ahora existe. Si echo un vistazo a los datos, veo que tengo una tabla, es la tabla de ubicaciones, veo la dirección y, a continuación, veo los datos en sí. Ahí vamos. Es todo lo que hice. Acabo de revisar los primeros 10, así que ya están ahí. Ahora vamos a ejecutar esta cosa de nuevo y ponerla en marcha. Ahora lo que va a hacer es leer todo el archivo de where.data. Pero te darás cuenta de que ya tiene las 10 primeras listas. Solo dice que lo tengo. Llega muy rápido a los 10 primeros. Ahora se queda con los 10 siguientes y ahora se queda con los diez siguientes. De nuevo, digamos que su red deja de funcionar y todo explota. Bueno, echemos un vistazo a los datos. Ahora tenemos 30. Puede que sean 3000 en lugar de 30, pero regresas por la mañana como si hubiera explotado. ¿Qué es lo que haces? Lo vuelves a poner en marcha. Ahora va, oh, tengo todos esos. Estos son los próximos 10. Estos son los próximos 10. Vamos a resumir esto y comentémoslo brevemente para que se haga más rápido. Ahora no va a dormir. Dirá que hace una pausa, pero va a desaparecer. Ahora que se está recuperando, veremos cómo tiene que llegar a 257. Una vez más, estos son buenos datos, están analizando 257 de estas cosas. No llegué a 25 000 ni a un millón, pero este patrón podría funcionar. Llegó a 100, así que tuve que volver a ejecutarlo porque tenía otro límite, solo 100. Llegaremos allí. Sigue cargando. Quiero llegar a lo mío en el que tengo que tener en cuenta que hubo un error y tú podrías haber ido a ver cuál era ese error. Aún tengo que volver a conseguirlo. Tengo que ejecutarlo. Debería haber cambiado la línea. De hecho, puedes ver que es lento. Llegó al límite de velocidad. Deja que vuelva a dormir. Curiosamente, ahora que lo ejecutamos, hemos revisado, bueno, echemos un vistazo a nuestra base de datos por un segundo. Vamos a recargar la base de datos y lo vemos, ahí vamos y el imbécil ya está ahí. Esa es la que he añadido. Hay 273 aquí. Ahora, mira lo que pasa cuando vuelvo a ejecutar esto. Ya está hecho. Echemos un vistazo a la cosa, porque lo que hacía allí era leer todas las cosas de where.data y comprobar Geodata SQLlight. Ya están ahí, por lo que no fue necesario ir a la API. Eso es lo que quiero decir con un proceso reiniciable. No es necesario volver a la API, por lo que puedo ejecutar esto tantas veces como quiera y es instantáneo básicamente porque solo se leen 250 cosas de una base de datos, lo que ocurre muy rápido. En cierto sentido, la forma en que puedes pensar en esto es que esta primera fase ha terminado. Lo reiniciamos un par de veces, hicimos esto, aquello y ahora queremos trabajar en esta segunda fase en la que ejecutamos geo dump y todo lo que hay que hacer. Echemos un vistazo al código. Estos dos tienen un aspecto muy diferente. A Geo Load le preocupa el hecho de que la API pueda fallar, que sea lenta o que se quede sin tiempo. Esta herramienta, geodump.py, abre una base de datos y luego lee todo esto y comienza a escribir este archivo where.js y algo extraño y divertido, y básicamente lee la primera fila, simplemente lee las filas, luego analiza el JSON y luego comprueba si esas características están ahí, que es lo externo. Vamos a echar un vistazo aquí. Los datos sin procesar y las bonitas funciones de impresión son esta cosa exterior. Es una serie de características, pero solo vamos a ver el cero con el elemento y, a continuación, vamos a analizar las propiedades secundarias o vamos a verlo de esta manera. Vamos a analizar las características, y esa es una matriz, así que vamos a ir a las zonas bajo cero, y luego a las propiedades laterales, vamos a tomar la longitud, la latitud y cualquier otra cosa que sea. Puedes ver estas pequeñas cosas. Vamos a analizar las subentidades de JSON, por debajo de cero, porque las entidades, como subgeometría de matriz, subcoordinan; el cero de la primera es la longitud y la latitud. Sigamos adelante y ejecutemos eso. Vamos a imprimirlo y, de hecho, lo escribiremos en este archivo where.js al mismo tiempo. Esto también va a ser muy rápido. Fue muy rápido porque solo leía de la base de datos y escribía en where.js y, luego, había algún problema con este en particular. No me voy a preocupar demasiado por eso, pero si miro where.js, es solo una variable de Javascript que contiene todos estos datos con la longitud, la latitud y el nombre, y así es como se colocan los alfileres en un mapa. Si ves where.html, esta no es una clase HTML. Solo te estoy dando esto. Utiliza un montón de HTML para usar OpenGeo para visualizar estas cosas. Ahora todo lo que voy a hacer es decir: Abre where.html y ya está. Este es el mapa. Estas son todas las ubicaciones recuperadas y si hago clic en una de estas cosas, ves esto. Puedo encontrar mi ubicación en algún lugar de aquí. Tengo un enlace en la Universidad de Michigan, donde decidió que está el centro de la Universidad de Michigan. No estoy seguro de estar de acuerdo con eso, pero bueno, está bien. Supongo que es un callejero abierto, pero el segundo fue el que puse y es el Jamaiican Jerk Pit, que es solo uno de mis restaurantes favoritos en todo el mundo. Ahí lo tienes, el Jamaiican Jerk Pit. Mi oficina se encuentra actualmente en este mismo edificio, y camino menos de media cuadra hasta el jamaiican Jerk pit. Básicamente, se trata de un recorrido por nuestro proceso de geocodificación reiniciable y, a continuación, de una visualización con Focus Street Map. Espero que lo hayas encontrado útil. Aplausos.