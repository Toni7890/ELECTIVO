Así que hemos aprendido sobre las claves foráneas. Hemos aprendido sobre JOIN. Hemos aprendido cómo normalizar los datos para eliminar los duplicados. Sin embargo, aún hay una cosa más básica sobre el modelado de datos que tenemos que aprender: las relaciones de muchos a muchos. Por eso, todo lo que hemos hecho hasta ahora es lo que llamamos uno a muchos. Y es decir, un álbum tiene muchos temas. Al final de estas flechas, y las vemos en algunos de los diagramas del modelo de datos de patas de gallo, un extremo es como muchos y luego hay otro. Así que un álbum, y luego muchos temas. Así que, este es el tipo de cosas que tenemos. Y tenemos una clave externa en el lado múltiple. Eso permite que haya muchas, muchas, muchas canciones en un álbum. Y luego otro álbum tendría muchas, muchas, muchas canciones. ¿Verdad? Y esa es la idea. Hay un conjunto de pistas que tienen lo mismo, quiero decir, esta es la duplicación de la que acabamos de deshacernos y eso se llama «muchos a uno» o «uno a muchos», ¿vale? Y ese es un formulario y es el más común y lo vemos en nuestras tablas donde tenemos genre_id o album_id y tenemos duplicados aquí y este es el lado múltiple, por lo que hay muchas de estas cosas para una de esas cosas. Y, como ejemplo de madre biológica e hijos, una madre biológica soltera puede tener muchos hijos. Y este también es un diagrama de patas de gallo. Y este poco parecido a una pata de gallo dice muchas cosas, y ahí aparece una. Así que cuando dibujamos estos diagramas de modelos de datos, a los que no hemos dedicado demasiado tiempo, siempre los dibujamos de forma que capturemos la multiplicidad o la cardinalidad de cada extremo de la relación. Ahora, eso es de uno a muchos. Pero a veces tenemos una relación entre datos que va de muchos a muchos y, francamente, en los datos musicales con los que hemos estado jugando, ya os he dicho que, bueno, en realidad hay muchos artistas en un álbum. Pero dije que no te preocupes por eso. Bueno, ahora nos vamos a preocupar por eso. Así que el ejemplo que tomé de Wikipedia son los libros y los autores. Hay muchos autores y muchos libros. Por lo tanto, un autor puede hablar con muchos libros y un libro puede tener diferentes autores con los que está relacionado. Por lo tanto, no podemos decir que ninguna de las dos sea una relación única, por lo que llamamos a esto una relación de muchos a muchos. En ambos extremos hay una relación de muchos a muchos. Pero en cuanto a la mesa que queremos hacer, no hay manera. No puedes poner ni una sola clave foránea en este lado. Vaya, vuelve. No podemos poner una clave externa en esta tabla para apuntar a Books. Y no podemos poner una clave externa en los libros que apunte a los autores porque sería una especie de clave externa situada en ambos lados. Y entonces construimos una mesa en el medio, ¿vale? Y en Wikipedia la llaman tabla de unión, le dan todo tipo de nombres a esta cosa, pero lo que hacemos es crear una pequeña tabla. Todavía tenemos una tabla de libros y una tabla de autores, pero luego tenemos una tabla que no modela más que la conexión entre ellas, por lo que descomponemos esta relación de muchos a muchos en una relación de muchos a uno y una relación de muchos a uno y estas dos cosas las podemos modelar correctamente utilizando exactamente las mismas técnicas que hemos estado utilizando todo el tiempo. Así pues, terminamos con una tabla que contiene dos claves externas y ninguna clave principal. Así que echemos un vistazo a cómo se ve esto cuando lo construimos y lo modelamos. Así que aquí vamos a tener algo que me importa mucho: los cursos y los usuarios. Esto tiene que ver con el hecho de que un usuario es miembro de muchos cursos y cada curso tiene muchos usuarios, por lo que la relación entre los cursos y los usuarios, la relación entre los miembros, es múltiple en ambos sentidos. Y simplemente no podemos modelar eso directamente. Así que hacemos una pequeña mesa en el centro, ¿verdad? Así que llamamos a esto la tabla de miembros o la tabla llamada Miembro. Todavía tenemos una tabla de usuarios y una tabla de cursos. Además, tenemos una clave principal en las tablas Curso y Usuario. Y lo que hacemos es tener esta tabla de miembros en la que cada fila tiene dos claves externas. Y es una conexión, así que si piensas en todos los cursos de un lado y en todos los usuarios del otro lado, en cada conexión, estos podrían ser amigos de personas, cada conexión tiene una fila que conecta un curso en particular con un usuario en particular. Y así es como funciona. Y entonces, esto descompone nuestra relación de muchos a muchos en dos mitades de dos de muchos a uno, para luego modelar la relación de muchos a muchos entre las dos tablas. No ponemos un identificador. No lo ponemos ahí, porque podemos crear una clave compuesta, es decir, ambas cosas son la clave principal de esa tabla. Ambos son números, se permite la duplicación, así que todo esto es perfecto. Ahora bien, a veces modelamos algo como poner un rol aquí para que puedas decir que está bien, esto son los cursos y los usuarios. Podríamos indicar que esta combinación particular de usuario/curso también es un instructor y esta en particular es un estudiante, ¿verdad? Por eso, a veces podemos poner un poco de información adicional en el propio enlace, y así tenemos una pequeña cantidad de datos que añadimos ahí abajo. ¿Vale? Así que hacemos una mesita en el centro, y aquí vamos a analizar algunas bases de datos. Voy a empezar con una base de datos nueva. Voy a crear una tabla de usuarios, la principal diferencia es que voy a dar la clave principal a los usuarios, voy a crear una tabla de cursos, y esta es nuestra clave principal estándar. Voy a poner un nombre y una dirección de correo electrónico para los usuarios y un título para los cursos. Y luego, esas son cosas normales que estamos acostumbrados a hacer. Pero ahora lo que vamos a hacer es crear una pequeña tabla de conectores que tendrá dos, un role_id y un course_id. Quiero decir, un user_id y un course_id. Y luego vamos a modelar un poco de datos, justo en el medio, y vamos a modelar un rol. Y esto nos permitirá decir si alguien es profesor o alumno. Y la otra cosa que estamos haciendo para sustituir efectivamente a esta clave principal es decir que nuestra clave principal está formada en realidad por dos columnas juntas. Y es la combinación. Así que esto lo obliga a ser único. Pero en realidad la combinación de user_id y course_id debe ser única. ¿Vale? Así que echemos un vistazo a esto. De hecho, sigamos y ejecutemos un poco de código. Entonces, lo que voy a sugerirle que haga es que comience con una base de datos nueva y fresca. Simplemente haga clic en Nueva base de datos. ¿Verdad? Y lo llamaremos, yo lo llamaré sql3, Nueva base de datos. Y no voy a hacer mi tabla ahí, voy a repasar el tema de Execute SQL, que espero que ya os resulte un poco cómodo. Y luego, voy a agarrar. En realidad, voy a coger estos dos. Primero, tomaremos esas dos instrucciones CREATE TABLE. Pondré un punto y coma al final de esta para que podamos analizar ambas. Vamos a ver si funcionaron. Sí, tengo un curso y un usuario, una clave principal, un título, una identificación, un nombre, exactamente lo que tenemos. Y ahora lo que vamos a hacer es ejecutar el SQL para crear la pequeña tabla de conectores. Así que lo pegaré y lo ejecutaré. Veamos si funcionó, y funcionó. Así que estamos todos bien, clave principal. Y ahora vamos a introducir algunos datos. Así que echemos un vistazo a algunos datos. Cuando terminemos, lo tendremos, y ya lo hemos visto. Vamos a insertar algunos usuarios y algunos cursos, así que echémosle un vistazo antes de empezar a hacerlo. Como tienen claves principales que se incrementan automáticamente, vamos a insertar el nombre y el correo electrónico jane@tsugi.org y vamos a insertar tres usuarios y, a continuación, vamos a obtener los identificadores de usuario y, a continuación, vamos a insertar tres cursos, Python, SQL y PHP. Así que nos limitaremos a hacer esas cosas. No son nada especial. No son diferentes de las cosas que hemos estado haciendo todo el tiempo. Ve aquí en SQL. Todas tienen punto y coma al final. Todo funcionó, así que examinaremos los datos. Vemos los datos del curso. Y vemos los datos del usuario. Y no hay nada en los datos de membresía. Quiero decir, la base de datos no sabe que hemos hecho algo así. Acabamos de insertar algunas cosas aquí. Y lo que realmente estamos haciendo es establecer la clave principal en esta columna de identificación. Así que Python es 1. SQL es 2 y PHP es 3. Ahora vamos a poner algunos datos en la columna de miembros y en el rol user_id, course_id. Así que vamos a conectar a un usuario a un curso y, a continuación, asignar un rol a esa membresía en particular. Así que este es un registro de miembros, en el que se indica quién es miembro de qué y algún aspecto del mismo. Y puede haber algunas cosas que a menudo son unas cuantas columnas más que podrías hacer. Así que echemos un vistazo a lo que tenemos que hacer para insertar realmente a los usuarios en los cursos. ¿Verdad? Así que estos son los números que tenemos. Así que ahora lo que vamos a hacer es insertar en la tabla de miembros los registros de inscripción, por así decirlo. Así que tenemos que insertar el user_id, el course_id, las claves externas y, a continuación, el rol. Así que esto dice: el usuario 1 estará en el curso 1 y haremos que el 1 sea el instructor, ¿de acuerdo? Y luego decimos que el usuario 2 está en el curso 1 como estudiante. El usuario 3 está en el curso 1 como estudiante. El usuario 1 es el alumno del curso 2. El usuario 2 está en el curso 2 como instructor. Etc., etc. Así que, dado que sabemos cuáles son estos números en código real, sabremos cuáles son los números. Sabemos cuáles son los números, así que los colocamos directamente en las instrucciones de inserción. Y así es como hacemos nuestras conexiones. Así que sigamos y ejecutémoslos, vayamos a SQL e insertemos todos esos. Haga clic. Oh, caramba, espero no haberlo hecho dos veces. No, no lo hice dos veces. Me alegro. Déjame refrescarme para asegurarme de que no lo hice dos veces. Bien, esos son solo los números que provienen de esos insertos y del instructor, el instructor, el instructor, los cursos y los estudiantes. ¿Vale? Y ahora lo que tenemos es que tenemos en nuestra base de datos, ahora hemos conectado estas cosas entre sí. ¿Verdad? Así que los tenemos todos conectados. Tenemos nuestra tabla de usuarios, tenemos nuestra tabla Ccourse y luego tenemos nuestros conectores que van de aquí a aquí y de aquí a aquí. Y estamos modelando una pequeña cantidad de datos en la conexión, eso es lo que llamaríamos. En la conexión, ¿vale? Bien, saquemos algunos datos de esta tabla ahora. Vamos a escribir una instrucción de selección, SELECT User.Name, Member.Role y, a continuación, Course.title. Vamos a seleccionar las del usuario, las que se unieron al miembro y las uniremos al curso, así que las uniremos todas en una fila grande y larga. Usamos la cláusula ON y el Member.USER_ID es igual al ID del usuario y de los miembros y los cursos, el ID del curso de membresía es igual al ID del curso. Member.course_ID es igual al ID del curso. Ah, y luego vamos a hacer cosas interesantes. Vamos a ordenarlos por título del curso y luego por rol de miembro. La forma en que estas. Y luego el rol del miembro en orden descendente y, por último, el nombre de usuario. Lo que esto significa es que la prioridad es que el título del curso es lo más importante. El papel es lo siguiente más importante. Y lo haremos de forma descendente y, luego, el nombre de usuario es la tercera cosa más importante. Esto nos permitirá ordenar primero por curso y, después, dentro del curso, primero por su función, y luego, para las personas que tienen la misma función, esta tiene la misma función, por lo que esto nos permitirá ver primero a los profesores y luego a los alumnos en orden alfabético, ya que el rol es 1 para los profesores y 0 para los estudiantes, ¿de acuerdo? Eso es lo que obtenemos cuando nos unimos, por lo que hemos creado un registro de inscripciones. Si tuviéramos una cláusula WHERE, podríamos elegirla para un curso en particular, etc., etc. Así que sigamos con esa selección. Sería muy aburrido si todo saliera bien. Ejecute SQL. Pegue ese SQL. Y ejecuta ese SQL. Así vemos que está ordenado por curso, luego ordenado por rol y, dentro del mismo rol, está ordenado por nombre de estudiante. ¿Vale? Así que ese era un ejemplo de tres cosas de la cláusula ORDER BY. Está bien. Entonces, verás que esto funciona si observas varios modelos de datos. En realidad, este es un modelo de datos para su grabadora automática. Utiliza un software llamado Tsugi. Y la interacción entre el sistema de aprendizaje y Tsugi tiene que modelar cosas como el curso del que vienes, los miembros que eres, si eres profesor o no, por lo que si analizo esto, no es que realmente necesites analizarlo con gran detalle, tenemos un software de producción, una tabla de usuarios, un contexto que es el mismo que el del curso, y luego la membresía, y la membresía tiene muchos, muchos a uno. Por lo tanto, tenemos una relación de muchos a muchos entre los usuarios y los cursos, pero la modelamos con esta pequeña tabla que es la tabla de conectores. Y ahí hay una función. Como es de esperar en cualquier entorno de enseñanza y aprendizaje, harás un seguimiento del puesto. Y tengo una cosa llamada anulación de roles. Y también tengo dos pequeñas cosas que registran cuándo suceden las cosas. Y así pues, veamos. Así que algunos de estos. Algunos de estos. Así que esa es una relación de muchos a muchos. La mayoría de estas otras cosas son de muchos a uno. Esta es una relación de muchos a uno. Así que esta es una pata de gallo modificada. Esta es una relación de muchos a uno entre el enlace del curso. Resulta que este es el enlace en el que haces clic. Bla , bla, bla, bla. Y esta es en realidad tu calificación. Y los resultados son excelentes, por lo que hay muchos resultados para un enlace, y eso se debe a que cada estudiante obtiene su propia calificación. Bien, resulta que este es el modelo de datos para este software que has estado utilizando, quizás, durante varios meses. Pero ves una de estas relaciones de muchos a muchos. Está bien. Entonces, ¿por qué hicimos todo esto? ¿Por qué hicimos todas estas cosas? ¿Por qué hicimos estos pequeños números enteros? ¿Por qué te hablamos de JOIN? ¿Por qué enseñamos sobre muchos a muchos? ¿Por qué hicimos que tus datos parecieran tan locos? Y todo tiene que ver con la velocidad. Y se podría decir que no me importa la velocidad. Y resulta que hay muchos programas para los que no te importa la velocidad. Ya sabes, el pequeño programa para calcular el piso de EE. UU. a partir del piso de Europa. No importa. No importa leer 10 000 líneas de un archivo. Sin embargo, cuando se crea una aplicación SAN en línea o incluso una aplicación de análisis de datos de gran tamaño, la velocidad empieza a importar. Entonces, lo que pasa es que sobrepasas este momento en el que todo se vuelve demasiado lento. Y entonces, la única forma de hacerlo rápido es hacerlo realmente rápido. Y así, cuando usas bases de datos, puedes hacer cosas que parecen increíblemente rápidas. Así pues, toda esta normalización, la cantidad de datos que se almacenan, la cantidad de datos que se escanean, se pierde realmente. Y no es realmente una compensación. O lo tuyo es lo suficientemente pequeño como para no tener que hacerlo, o cruzas este punto en el que tu solicitud fallará a menos que tú no lo hagas. Y por eso es que es importante tener esta habilidad. Por lo tanto, hemos cubierto una gran cantidad de SQL en un corto período de tiempo. Hay mucho más que aprender. La gente siempre me pregunta si hay una clase avanzada de SQL, y yo digo: bueno, es como una clase de SQL para empezar y luego para el resto de tu vida. Porque siempre puedes aprender más sobre el lenguaje de consulta estructurado y cómo funcionan las bases de datos, qué funciona rápido y qué no. Hay un par de cosas que puedes buscar como temas que realmente no hemos tratado muy bien. Los índices tienen que ver con claves lógicas y las búsquedas de cadenas son muy rápidas. Restricciones. Teníamos algo que no era nulo. Hay otras restricciones que puedes imponer a los datos. Y transacciones. Son una forma de agrupar las operaciones, por ejemplo, si comienza una lectura, no hay más lecturas hasta que se produce una escritura. Por lo tanto, es una forma de bloquear cosas, por lo que todos estos temas son muy, muy importantes. Por lo tanto, las bases de datos relacionales podrían ser una profesión en sí mismas. El solo hecho de saber cómo crear bases de datos es impresionante. Diseñar bases de datos es impresionante. Espero que esto te haya llevado al punto en el que puedas entender un poco lo que está pasando, y luego, aprender el resto de tu vida. ¿Está bien? Nos vemos.