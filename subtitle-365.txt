Hola y bienvenidos a nuestro tutorial de códigos sobre el código de la lista. El objetivo de aprendizaje de esto es crear una tabla de muchos a muchos, por lo que la idea es que, tal como hablamos en la clase, tengamos un conjunto de usuarios, un conjunto de cursos y, luego, una tabla de conectores o una tabla de muchos a muchos que básicamente tenga dos claves foráneas. Vamos a utilizar el número entero, no nulo, de incremento automático único de la clave principal como forma de obtener la asignación automática de las claves principales en la tabla de usuarios y en la tabla del curso. Y luego, diremos que el nombre, que es como una clave lógica, y luego el título del curso, los marcaremos como únicos. Y vamos a aprovechar eso en un momento. Así verás cómo lo aprovechamos. Lo que significa único es que si intentas insertar la misma cadena en esta columna, ya sabes, como Chuck dos veces, la segunda vez fallará porque se negará a crear un nuevo registro. Así que si echamos un vistazo, obtendremos los datos de nuestra lista de este JSON de ejemplo, que es solo una matriz de matrices. Y este es el nombre de la persona, la clase en la que está y si es profesor o alumno. Así que vamos a leer eso. Necesitamos la biblioteca JSON y la biblioteca SQLite. Hacemos una conexión a la base de datos y obtenemos un cursor. El cursor es más parecido al identificador del archivo. Envía comandos SQL al cursor y, a continuación, lee el cursor para recuperar los datos. La conexión también puede crear más de un cursor, por lo que puede agregar más de un conjunto de comandos. Pero el cursor suele ser como el identificador de archivo del servidor de bases de datos. Vamos a ejecutar un gran script y se darán cuenta de que se trata de una cadena entre comillas triples que llega hasta aquí. Algunas personas simplemente te lo dan en un archivo de texto y te piden que lo cortes y lo pegues, y luego lo ejecutes en tu navegador SQLite para crearlos. Pero está bien, porque lo que vamos a hacer es configurar esto. Se volverá a conectar al nombre de archivo existente rosterdb.sqlite. Y si miro dónde estoy y hago un ls, nos damos cuenta de que ese archivo no está ahí. Así que la primera vez que lo ejecute lo creará, pero quiero que comience de cero cada vez, así que voy a borrar las tablas si existen. De esa forma, puede repetirlo una y otra vez, en caso de que cometa un error aquí. Ahora, no me equivoco, o espero no tener ningún error en esto. Así que vamos a crear, vamos a eliminar tres tablas y vamos a crear tres tablas. Y aquí, vamos a crear la tabla que tiene dos claves externas, user_id y course_id, que en cierto modo salen de la tabla de miembros. Y luego, vamos a modelar un poco de los datos del puesto. Una vez más, esto es sacado directamente de la conferencia. Y la clave principal es en realidad una clave principal compuesta porque vamos a buscarla y eso obligará a que la combinación de user_id y course_id sea única. Pero puede haber muchos ID de usuario y muchos ID de curso, pero solo una combinación concreta de un valor para user_id y course_id. Y eso es lo que básicamente estamos diciendo. Puede ser miembro de un curso, pero solo puede hacerlo una vez. No puedes ser como un miembro del curso un montón de veces. Vamos a hacerlo, debería ser roster_data_sample. Eso está bien. Uy. Corrige un error. Guarda eso, roster_data_sample. Y ese es solo este archivo. En realidad es solo una matriz y, por lo tanto, cada fila es una matriz. Y es una forma de introducir los datos de esta lista. Una vez que realicemos cargas en JSON, lo analizaremos. Y luego, esto va a ser una matriz de matrices. para introducir datos JSON, por lo que la entrada va a ser una de estas cosas. Así que la entrada en sí es una fila. Por lo tanto, la entrada sub cero es el nombre y la entrada sub uno es el título. Nombre, ese es el subcero y ese es el subuno de la entrada en particular que estamos viendo. Y vamos a imprimirlo como una tupla solo por Dios. Así que hacemos que eso es lo que son los dos paréntesis. Esta cosa interior es una doble tupla. Luego cogeremos a la persona y haremos una inserción, y esto es nuevo o lo ignoraremos. Por lo tanto, lo que significa o ignorar es que si este inserto provoca un error, no lo explote. No, simplemente ignore que intento insertarlo. Así que este es nuestro truco y es un truco hermoso. Es como un truco magníficamente hermoso. Aquí, si insertamos el nombre Chuck dos veces, o lo ignoramos, simplemente significará que no pasa nada. Lo que significa que ya está ahí. Vale, entonces si ya está ahí. Si no está ahí, lo pondrá. Y lo único garantizará que solo entre una vez. Así que, de hecho, siempre intentamos insertarlo. Si ha estado allí una vez, entonces está todo listo. Por eso, insertar o ignorar es un mecanismo superpoderoso. Lo uso todo el tiempo. Y tenemos un marcador de posición en forma de signo de interrogación. Y luego tenemos que uno de estos días pedir dos cosas. De hecho, aquí está, hay una tupla aquí abajo. Pero es una especie de tupla con un elemento, el nombre. Y ese nombre sustituirá entonces a «there without», evitando la inyección de SQL. Así que esto funciona. Puede que inserte o no un nuevo disco, pero si es Chuck o quien sea que no esté con ese nombre, nos dará un nuevo registro. Y luego vamos a recuperar la identificación. Así que esta es la clave lógica y esta es la clave principal. Esa clave principal se construirá automáticamente para nosotros. Así que necesitamos saber qué es. Por lo tanto, decimos que seleccione la identificación del usuario donde el nombre sea igual y luego ese mismo nombre. Así que ese es Chuck. Y eso nos da uno. Y luego, lo que hacemos es buscar un registro del cursor, porque es una selección y nos devuelve un cursor. Espero que solo haya un registro allí porque es único. Podría poner un límite de 1 allí, pero eso sería un poco redundante porque el nombre es una clave única. Y luego, el subcero solo significa que si hubiera más de una cosa que estuviera seleccionando, como verás en un momento, la subcero es solo lo primero. Y esto nos va a dar el entero, user_id, que se asignó, o si lo analizamos más tarde para Chuck, Chuck más tarde, Charlie más tarde, ese será el anterior. Por lo tanto, esto se inserta si no existe, y es obtener el campo de ID recién creado o el campo de ID original. Parte de esto funciona al tener una clave lógica y una clave principal. La clave principal se genera automáticamente, pero el nombre es una clave lógica y es única, por lo que ese es nuestro truco para que se le asigne esa cosa. Antes lo veíamos en la interfaz de usuario del navegador SQLite y lo escribíamos, pero así es como lo hacemos en código. Así que necesitamos saber qué es esa clave, si era nueva o no. Y luego, hacemos exactamente el mismo patrón para el curso, excepto que insertamos el título del curso. Así que no es gran cosa. Vamos a obtener el user_id, course_id. Y luego lo que vamos a hacer es insertarlo o reemplazarlo. Básicamente, si existe, recuerda que esta combinación user_id y course_id es la clave principal de esta tabla de miembros. Si hay un duplicado, si esta combinación ya existe, se convierte de hecho en un estado de actualización. Y tenemos estos dos valores numéricos. Ahora lo que falta aquí es que el papel no está ahí. Así que user_id, course_id, este es el bit SQL. Y ahora tenemos una tupla con dos elementos y eso es porque tenemos dos signos de interrogación. Y luego lo cometemos. Y como mencioné antes, a veces siempre quieres comprometerte a través de la confirmación. Resulta que estas cosas son menos costosas, pero eso se debe a que no siempre se escribe completamente en el disco. Mientras que, cuando escribes la confirmación, va a escribir todo en el disco, se detiene hasta que se complete y, a continuación, el programa no continúa. Así que a veces no revisamos esto todas las veces. ¿Vale? Así que sigamos adelante y ejecutemos esto. Lo único que vamos a ver es la salida del nombre y el título mientras se ejecuta. Así que python3 roster.py. Espero poder pulsar enter. Por cierto, te darás cuenta de que este SQLite ahora existe, ¿verdad? Y no contiene datos. Déjeme ver si puedo abrir esta base de datos y verla. Como puede ver, no hay datos. Así que nosotros somos el código, hemos ejecutado este código en vigor hasta este momento. Así que ya hemos creado tablas y todo eso. Así que las tablas de creación están ahí. Así que todos estos datos están aquí, lo hizo. Todavía no hemos empezado a introducir ningún dato en él porque, si analizamos los datos de navegación, no encontramos nada aquí. ¿Vale? No hay datos para buscar. Ahora, espero que no nos hayamos encerrado porque estamos sentados aquí. Y cuando pulse enter aquí, se apagará y funcionará muy rápido. Así que presioné enter , lo leerá e insertó todas esas cosas. Y ahora ha cambiado. Y si presiono actualizar aquí, veremos en el usuario que es una especie de ID de usuario asignado, ¿verdad? Columnas asignadas automáticamente. Descubriremos en el curso que todos esos cursos se asignan automáticamente. Ahí están los cursos. Y no hay duplicados porque es único, ¿verdad? Así que estas son las cosas recién creadas. Pero entonces, la membresía es user_id, course_id. Por lo tanto, la clave principal, por así decirlo, las restricciones únicas como clave principal son la combinación de estas cosas. Y no he puesto nada en el papel. Por lo tanto, si te desplazas por ellos, verás a todos los usuarios que son miembros de los cursos de los que forman parte. ¿Vale? Así que ahí lo tienes. Y dejaré que tú decidas la unión. Dejaré que tú decidas cómo incluir el papel. Pero solo quería explicarles un poco esta base de códigos y, en particular, los trucos de las claves de unicidad, las teclas de incremento automático, la unicidad de las claves lógicas y, luego, este tipo de clave principal compuesta, y luego el truco de insertar o ignorar, y luego la selección rápida que viene justo después para obtener el ID recién generado o para obtener el ID anterior. Y luego inserte o reemplace, que es una combinación de una inserción y una actualización. Espero que este ejemplo le haya resultado útil y pueda aplicarlo y, básicamente, crear tablas de muchas a muchas.